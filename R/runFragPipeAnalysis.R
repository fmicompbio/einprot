#' Run analysis on FragPipe data
#'
#' @param templateRmd Path to the template Rmd. Typically does not need to
#'     be modified.
#' @param outputDir Path to a directory where all output files will be
#'     written. Will be created if it doesn't exist.
#' @param outputBaseName Character string providing the 'base name' of the
#'     output files. All output files will start with this prefix.
#' @param reportTitle,reportAuthor Character scalars, giving the title and
#'     author for the result report.
#' @param forceOverwrite Logical, whether to force overwrite an existing
#'     Rmd file with the same \code{outputBaseName} in the \code{outputDir}.
#' @param experimentInfo Named list with information about the experiment.
#'     Each entry of the list must be a scalar value.
#' @param species Character scalar providing the species. Must be one of the
#'     supported species (see \code{getSupportedSpecies()}). Either the common
#'     or the scientific name can be used.
#' @param fragpipeDir Character string pointing to the FragPipe output folder.
#'     Must contain files <fragpipeDir>/combined_protein.tsv,
#'     <fragpipeDir>/fragpipe_*.config (or <fragpipeDir>/fragpipe.workflow) and
#'     <fragpipeDir>/log_*.txt
#' @param idCol,labelCol,geneIdCol,proteinIdCol,stringIdCol Arguments defining
#'     the feature identifiers (row names, should be unique),
#'     feature labels (for plots, can be anything),
#'     gene IDs (single gene symbols, will be matched against complexes and
#'     GO terms, can be \code{NULL}),
#'     protein IDs (UniProt IDs, will be used to create automatic URLs and
#'     match to species-specific identifiers, each entry can consist of
#'     multiple UniProt IDs separated by semicolons), and
#'     stringIdCol (single gene or protein ID, will be used to retrieve
#'     STRING networks, can be \code{NULL}).
#'     Each of these arguments can be either a character vector of column
#'     names in the input file (after application of \code{make.names}),
#'     in which case the corresponding feature ID
#'     is generated by simply concatenating the values in these columns, or a
#'     function with one input argument (a data.frame, corresponding to the
#'     annotation columns of the input file), returning a
#'     character vector corresponding to the desired feature IDs.
#' @param iColPattern Regular expression identifying the columns of the FragPipe
#'     \code{combined_protein.tsv} file to use for the analysis. Typically
#'     "\\.MaxLFQ\\.Intensity$"
#' @param sampleAnnot A \code{data.frame} with at least columns named
#'     \code{sample} and \code{group}, used to explicitly specify the group
#'     assignment for each sample. It can also contain a column named
#'     \code{batch}, in which case this will be used as a covariate in
#'     the \code{limma} or \code{proDA} tests. The values in the \code{sample}
#'     column should correspond to the names of the columns of interest in the
#'     input file, after removing the \code{iColPattern}.
#' @param includeOnlySamples,excludeSamples Character vectors defining specific
#'     samples to include or exclude from all analyses.
#' @param minScore Numeric, minimum score for a protein to be retained in the
#'     analysis. Set to \code{NULL} if no score filtering is desired.
#' @param minPeptides Numeric, minimum number of peptides for a protein to be
#'     retained in the analysis. Set to \code{NULL} if no filtering on the
#'     number of peptides is desired.
#' @param imputeMethod Character string defining the imputation method to use.
#'     Currently, \code{"impSeqRob"} and \code{"MinProb"} are supported.
#' @param assaysToExport Character vector defining the name(s) of the assays
#'     to use for exported abundances and barplots. This could, for example,
#'     be set to an assay containing 'absolute' abundances, if available, even
#'     if another assay is used for the actual analysis and comparison of
#'     groups. If set to \code{NULL} or an assay name that does not exist in
#'     the SingleCellExperiment object, the 'main' assay (defined by
#'     \code{iColPattern}) will be used.
#' @param mergeGroups Named list of character vectors defining sample groups
#'     to merge to create new groups, that will be used for comparisons.
#'     Any specification of \code{comparisons} or \code{ctrlGroup} should
#'     be done in terms of the new (merged) group names.
#' @param comparisons List of character vectors defining comparisons to
#'     perform. The first element of each vector represents the
#'     denominator of the comparison. If not empty, \code{ctrlGroup} and
#'     \code{allPairwiseComparisons} are ignored.
#' @param ctrlGroup Character scalar defining the sample group to use as
#'     control group in comparisons.
#' @param allPairwiseComparisons Logical, should all pairwise comparisons be
#'     performed?
#' @param singleFit Logical scalar indicating whether a single model fit
#'     should be used (and results for pairwise comparisons extracted via
#'     contrasts). If \code{FALSE}, the data set will be subset to the
#'     relevant samples for each comparison. Only applicable if
#'     \code{stattest} is \code{"limma"} or \code{"proDA"}.
#' @param subtractBaseline Logical scalar, whether to subtract the background/
#'     reference value for each feature in each batch before fitting the
#'     model. If \code{TRUE}, requires that a 'batch' column is available.
#' @param baselineGroup Character scalar representing the reference group.
#'     Only used if \code{subtractBaseline} is \code{TRUE}, in which case the
#'     abundance values for a given sample will be adjusted by subtracting the
#'     average value across all samples in the \code{baselineGroup} from the
#'     same batch as the original sample.
#' @param normMethod Character scalar indicating the normalization method to
#'     use. Currently, any method from \code{MsCoreUtils::normalizeMethods()}
#'     or \code{"none"} are valid values.
#' @param spikeFeatures Character vector indicating the 'spike-in' features
#'     to use for estimation of normalization factors. If \code{NULL}
#'     (default), all features are used.
#' @param stattest Either \code{"ttest"}, \code{"limma"} or \code{"proDA"},
#'     the testing framework to use. Could also be \code{"none"} if no test
#'     should be performed.
#' @param minNbrValidValues Numeric, the minimum number of valid values for a
#'     protein to be used for statistical testing.
#' @param minlFC Numeric, minimum log fold change to test against (only used
#'     if \code{stattest = "limma"}).
#' @param samSignificance Logical scalar, indicating whether the SAM statistic
#'     should be used to determine significance (similar to the approach used by
#'     Perseus). Only used if \code{stattest = "ttest"}. If \code{FALSE}, the
#'     p-values are adjusted using the Benjamini-Hochberg approach and used
#'     to determine significance.
#' @param nperm Numeric, number of permutations to use in the statistical
#'     testing (only used if \code{stattest = "ttest"}).
#' @param volcanoAdjPvalThr Numeric, adjusted p-value threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoLog2FCThr Numeric, log-fold change threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoMaxFeatures Numeric, maximum number of significant features
#'     to label in the volcano plots.
#' @param volcanoLabelSign Character scalar, either 'both', 'pos', or 'neg',
#'     indicating whether to label the most significant features regardless of
#'     sign, or only those with positive/negative log-fold changes.
#' @param volcanoS0 Numeric, S0 value to use to generate the significance
#'     curve in the volcano plots (only used if \code{stattest = "ttest"}).
#' @param volcanoFeaturesToLabel Character vector with features to always
#'     label in the volcano plots (regardless of significance).
#' @param addInteractiveVolcanos Logical scalar indicating whether to add
#'     interactive volcano plots to the html report. For experiments with
#'     many quantified features or many comparisons, setting this to
#'     \code{TRUE} can make the html report very large and difficult to
#'     interact with.
#' @param interactiveDisplayColumns Character vector (or \code{NULL})
#'     indicating which columns to include in the tooltip for the
#'     interactive volcano plots. The default shows the feature ID.
#' @param interactiveGroupColumn Character scalar (or \code{NULL}, default)
#'     indicating the column to group points by in the interactive volcano
#'     plot. Hovering over a point will highlight all other points with the
#'     same value of this column.
#' @param complexFDRThr Numeric, FDR threshold for significance in testing
#'     of complexes.
#' @param maxNbrComplexesToPlot Numeric, the maximum number of significant
#'     complexes for which to make separate volcano plots. Defaults to
#'     \code{Inf}, i.e., no limit.
#' @param seed Numeric, random seed to use for any non-deterministic
#'     calculations.
#' @param includeFeatureCollections Character vector, a subset of
#'     c("complexes", "GO").
#' @param minSizeToKeepSet Numeric scalar indicating the smallest number of
#'     features that have to overlap with the current data set in order to
#'     retain a feature set for testing.
#' @param customComplexes List of character vectors providing custom complexes
#'     to test for significant differences between groups.
#' @param complexSpecies Either \code{"all"} or \code{"current"}, depending
#'     on whether complexes defined for all species, or only those defined
#'     for the current species, should be tested for significance.
#' @param complexDbPath Character string providing path to the complex DB
#'     file (generated with \code{makeComplexDB()}).
#' @param stringVersion Character scalar giving the version of the STRING
#'     database to query.
#' @param stringDir Character scalar (or \code{NULL}) providing the path to a
#'     folder where the STRING files will be downloaded (or loaded from, if
#'     they already exist). If \code{NULL} (default), they will be downloaded
#'     to a temporary directory.
#' @param linkTableColumns Character vector with regular expressions that will
#'     be matched against the column names of the rowData of the generated
#'     SingleCellExperiment object and included in the link table in the end
#'     of the report.
#' @param customYml Character string providing the path to a custom YAML file
#'     that can be used to overwrite default settings in the report. If set
#'     to \code{NULL} (default), no alterations are made.
#' @param doRender Logical scalar. If \code{FALSE}, the Rmd file will be
#'     generated (and any parameters injected), but not rendered.
#'
#' @export
#' @author Charlotte Soneson
#'
#' @return Invisibly, the path to the compiled html report.
#'
#' @importFrom xfun Rscript_call
#' @importFrom rmarkdown render
#' @importFrom readr read_file write_file
#' @import STRINGdb
#' @importFrom SummarizedExperiment rowData colData assay assayNames
#' @importFrom DT datatable
#' @importFrom limma removeBatchEffect
#' @importFrom ExploreModelMatrix VisualizeDesign
#' @importFrom cowplot plot_grid theme_cowplot
#' @importFrom htmltools tagList
#' @importFrom dplyr %>% select starts_with full_join filter matches everything
#'     mutate
#' @importFrom knitr current_input
#' @importFrom ComplexUpset upset
#' @importFrom ggplot2 ggplot aes geom_bar coord_flip theme_bw labs theme
#'     element_text geom_point ggtitle
#' @importFrom tibble rownames_to_column
#' @importFrom S4Vectors metadata
#' @importFrom scater runPCA
#' @importFrom SingleCellExperiment reducedDim
#' @importFrom BiocSingular ExactParam
#' @importFrom ggalt geom_encircle
#' @importFrom plotly ggplotly
#' @importFrom ComplexHeatmap Heatmap columnAnnotation draw
#'
runFragPipeAnalysis <- function(
    templateRmd = system.file("extdata/process_FragPipe_template.Rmd",
                              package = "einprot"),
    outputDir = ".", outputBaseName = "FragPipeAnalysis",
    reportTitle = "FragPipe LFQ data processing", reportAuthor = "",
    forceOverwrite = FALSE,
    experimentInfo = list(), species, fragpipeDir,
    idCol = function(df) combineIds(df, combineCols = c("Gene", "Protein.ID")),
    labelCol = function(df) combineIds(df, combineCols = c("Gene", "Protein.ID")),
    geneIdCol = function(df) getFirstId(df, colName = "Gene"),
    proteinIdCol = "Protein.ID",
    stringIdCol = function(df) combineIds(df, combineCols = c("Gene", "Protein.ID"),
                                          combineWhen = "missing", makeUnique = FALSE),
    iColPattern, sampleAnnot,
    includeOnlySamples = "", excludeSamples = "",
    minScore = 10, minPeptides = 2, imputeMethod = "MinProb",
    assaysToExport = NULL, mergeGroups = list(), comparisons = list(),
    ctrlGroup = "", allPairwiseComparisons = TRUE, singleFit = FALSE,
    subtractBaseline = FALSE, baselineGroup = "", normMethod = "none",
    spikeFeatures = NULL, stattest = "limma", minNbrValidValues = 2,
    minlFC = 0, samSignificance = TRUE, nperm = 250, volcanoAdjPvalThr = 0.05,
    volcanoLog2FCThr = 1, volcanoMaxFeatures = 25, volcanoLabelSign = "both",
    volcanoS0 = 0.1, volcanoFeaturesToLabel = "",
    addInteractiveVolcanos = FALSE, interactiveDisplayColumns = NULL,
    interactiveGroupColumn = NULL, complexFDRThr = 0.1,
    maxNbrComplexesToPlot = Inf, seed = 42,
    includeFeatureCollections = c(), minSizeToKeepSet = 2, customComplexes = list(),
    complexSpecies = "all", complexDbPath = NULL, stringVersion = "11.5",
    stringDir = NULL, linkTableColumns = c(), customYml = NULL, doRender = TRUE
) {
    ## --------------------------------------------------------------------- ##
    ## Fix ctrlGroup/mergeGroups
    ## --------------------------------------------------------------------- ##
    ## For backward compatibility: If mergeGroups is list(), and ctrlGroup
    ## is a vector (the way things were specified before v0.3.2), add the
    ## merged ctrl group to mergeGroups. Raise an error if mergeGroups is
    ## not empty and ctrlGroup is a vector.
    if (length(mergeGroups) > 0 && length(ctrlGroup) > 1) {
        stop("If 'mergeGroups' is specified, 'ctrlGroup' should not ",
             "be a vector.")
    }
    if (length(mergeGroups) == 0 && length(ctrlGroup) > 1) {
        mergeGroups <- list()
        newCtrlName <- paste(ctrlGroup, collapse = ".")
        mergeGroups[[newCtrlName]] <- ctrlGroup
        ctrlGroup <- newCtrlName
    }

    ## --------------------------------------------------------------------- ##
    ## Check arguments
    ## --------------------------------------------------------------------- ##
    .checkArgumentsFragPipe(
        templateRmd = templateRmd, outputDir = outputDir,
        outputBaseName = outputBaseName, reportTitle = reportTitle,
        reportAuthor = reportAuthor, forceOverwrite = forceOverwrite,
        experimentInfo = experimentInfo, species = species,
        fragpipeDir = fragpipeDir, idCol = idCol, labelCol = labelCol,
        geneIdCol = geneIdCol, proteinIdCol = proteinIdCol, stringIdCol = stringIdCol,
        iColPattern = iColPattern, sampleAnnot = sampleAnnot,
        includeOnlySamples = includeOnlySamples,
        excludeSamples = excludeSamples, minScore = minScore,
        minPeptides = minPeptides, imputeMethod = imputeMethod,
        assaysToExport = assaysToExport, mergeGroups = mergeGroups,
        comparisons = comparisons, ctrlGroup = ctrlGroup,
        allPairwiseComparisons = allPairwiseComparisons, singleFit = singleFit,
        subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
        normMethod = normMethod, spikeFeatures = spikeFeatures, stattest = stattest,
        minNbrValidValues = minNbrValidValues, minlFC = minlFC,
        samSignificance = samSignificance,
        nperm = nperm, volcanoAdjPvalThr = volcanoAdjPvalThr,
        volcanoLog2FCThr = volcanoLog2FCThr,
        volcanoMaxFeatures = volcanoMaxFeatures,
        volcanoLabelSign = volcanoLabelSign,
        volcanoS0 = volcanoS0, volcanoFeaturesToLabel = volcanoFeaturesToLabel,
        addInteractiveVolcanos = addInteractiveVolcanos,
        interactiveDisplayColumns = interactiveDisplayColumns,
        interactiveGroupColumn = interactiveGroupColumn,
        complexFDRThr = complexFDRThr,
        maxNbrComplexesToPlot = maxNbrComplexesToPlot, seed = seed,
        includeFeatureCollections = includeFeatureCollections,
        minSizeToKeepSet = minSizeToKeepSet,
        customComplexes = customComplexes, complexSpecies = complexSpecies,
        complexDbPath = complexDbPath, stringVersion = stringVersion,
        stringDir = stringDir, linkTableColumns = linkTableColumns,
        customYml = customYml, doRender = doRender)

    ## If pandoc is not available, don't run it (just generate .md file)
    ## Gives a warning if pandoc and/or pandoc-citeproc is not available
    pandocOK <- .checkPandoc(ignorePandoc = TRUE)

    ## --------------------------------------------------------------------- ##
    ## Copy Rmd template and insert arguments
    ## --------------------------------------------------------------------- ##
    confighook <- "ConfigParameters"

    ## Concatenate Rmd chunk yml
    configchunk <- .generateConfigChunk(
        list(experimentInfo = experimentInfo, species = species,
             fragpipeDir = fragpipeDir, idCol = idCol, labelCol = labelCol,
             geneIdCol = geneIdCol, proteinIdCol = proteinIdCol, stringIdCol = stringIdCol,
             reportTitle = reportTitle, reportAuthor = reportAuthor,
             iColPattern = iColPattern, sampleAnnot = sampleAnnot,
             includeOnlySamples = includeOnlySamples,
             excludeSamples = excludeSamples, minScore = minScore,
             minPeptides = minPeptides, imputeMethod = imputeMethod,
             assaysToExport = assaysToExport, mergeGroups = mergeGroups,
             comparisons = comparisons, ctrlGroup = ctrlGroup,
             allPairwiseComparisons = allPairwiseComparisons,
             singleFit = singleFit,
             subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
             normMethod = normMethod, spikeFeatures = spikeFeatures, stattest = stattest,
             minNbrValidValues = minNbrValidValues, minlFC = minlFC,
             samSignificance = samSignificance,
             nperm = nperm, volcanoAdjPvalThr = volcanoAdjPvalThr,
             volcanoLog2FCThr = volcanoLog2FCThr,
             volcanoMaxFeatures = volcanoMaxFeatures,
             volcanoLabelSign = volcanoLabelSign,
             volcanoS0 = volcanoS0, volcanoFeaturesToLabel = volcanoFeaturesToLabel,
             addInteractiveVolcanos = addInteractiveVolcanos,
             interactiveDisplayColumns = interactiveDisplayColumns,
             interactiveGroupColumn = interactiveGroupColumn,
             complexFDRThr = complexFDRThr,
             maxNbrComplexesToPlot = maxNbrComplexesToPlot, seed = seed,
             includeFeatureCollections = includeFeatureCollections,
             minSizeToKeepSet = minSizeToKeepSet,
             customComplexes = customComplexes, complexSpecies = complexSpecies,
             complexDbPath = complexDbPath, stringVersion = stringVersion,
             stringDir = stringDir, linkTableColumns = linkTableColumns)
    )

    ## Read Rmd
    rmd <- readr::read_file(templateRmd)

    ## Determine where to insert the config chunk
    ## From https://community.rstudio.com/t/how-to-write-r-script-into-rmd-as-functioning-code-chunk/37453/2
    # header_regex <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
    #                         confighook,
    #                         confighook)
    header_regex <- sprintf("{{%sStart}}\n\n{{%sEnd}}",
                            confighook,
                            confighook)

    ## Replace hooks with config chunk
    output <- sub(header_regex, configchunk, rmd, fixed = TRUE)

    ## Similarly, add any custom yaml
    ymlhook <- "YmlParameters"
    # header_regex_yml <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
    #                             ymlhook,
    #                             ymlhook)
    header_regex_yml <- sprintf("{{%sStart}}\n\n{{%sEnd}}",
                                ymlhook,
                                ymlhook)
    if (!is.null(customYml)) {
        customYml <- paste(readLines(customYml), collapse = "\n")
    } else {
        customYml <- ""
    }
    output <- sub(header_regex_yml, customYml, output, fixed = TRUE)

    ## Write output to file
    if (!dir.exists(outputDir)) {
        dir.create(outputDir, recursive = TRUE)
    }
    outputFile <- file.path(outputDir, paste0(outputBaseName, ".Rmd"))
    if (file.exists(outputFile) && !forceOverwrite) {
        stop(outputFile, " already exists and forceOverwrite = FALSE, stopping.")
    } else if (file.exists(outputFile) && forceOverwrite) {
        message(outputFile, " already exists but forceOverwrite = TRUE, overwriting.")
    }
    readr::write_file(output, file = outputFile)

    ## --------------------------------------------------------------------- ##
    ## Render the Rmd file
    ## --------------------------------------------------------------------- ##
    args <- list()
    args$input <- outputFile
    args$output_format <- "html_document"
    args$output_dir <- outputDir
    args$intermediates_dir <- outputDir
    args$quiet <- FALSE
    args$run_pandoc <- pandocOK

    if (doRender) {
        #nocov start
        outputReport <- xfun::Rscript_call(
            rmarkdown::render,
            args
        )
        #nocov end
    } else {
        outputReport <- outputFile
    }

    ## --------------------------------------------------------------------- ##
    ## Return (invisibly) the path to the rendered html file
    ## --------------------------------------------------------------------- ##
    invisible(outputReport)
}
