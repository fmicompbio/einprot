#' Run PTM analysis on PD/TMT data
#'
#' @param templateRmd Path to the template Rmd. Typically does not need to
#'     be modified.
#' @param outputDir Path to a directory where all output files will be
#'     written. Will be created if it doesn't exist.
#' @param outputBaseName Character string providing the 'base name' of the
#'     output files. All output files will start with this prefix.
#' @param reportTitle,reportAuthor Character scalars, giving the title and
#'     author for the result report.
#' @param forceOverwrite Logical, whether to force overwrite an existing
#'     Rmd file with the same \code{outputBaseName} in the \code{outputDir}.
#' @param experimentInfo Named list with information about the experiment.
#'     Each entry of the list must be a scalar value.
#' @param species Character scalar providing the species. Must be one of the
#'     supported species (see \code{getSupportedSpecies()}).
#' @param sceProteins,scePeptides Character strings pointing to .rds files with
#'     \code{SingleCellExperiment} objects containing proteins and
#'     peptides, respectively and generated by \code{runPDTMTAnalysis()}.
#' @param assayForTests Character string giving the name of the assay to
#'     use for testing.
#' @param assayImputation Character string giving the name of the assay
#'     containing information about the imputation status of each observation.
#' @param proteinIdColProteins,proteinIdColPeptides Character strings pointing
#'     to columns of the \code{rowData} of the respective objects that
#'     contain the protein identifiers (will be used to match the two objects).
#' @param modificationsCol Character string pointing to a column of the
#'     \code{rowData} of the peptides object that contain modification
#'     details. \code{excludeUnmodifiedPeptides} and \code{keepModifications}
#'     will use information from this column.
#' @param excludeUnmodifiedPeptides Logical scalar, whether to filter out
#'     peptides without modifications.
#' @param keepModifications Character string (or \code{NULL}) indicating
#'     which modifications to retain in the analysis. Can be a regular
#'     expression, which will be matched against the \code{modificationsCol}.
#'     If \code{NULL} (the default), all rows are retained.
#' @param comparisons List of character vectors defining comparisons to
#'     perform. The first element of each vector represents the
#'     denominator of the comparison. If not empty, \code{ctrlGroup} and
#'     \code{allPairwiseComparisons} are ignored.
#' @param ctrlGroup Character vector defining the sample group(s) to use as
#'     control group in comparisons.
#' @param allPairwiseComparisons Logical, should all pairwise comparisons be
#'     performed?
#' @param singleFit Logical scalar indicating whether a single model fit
#'     should be used (and results for pairwise comparisons extracted via
#'     contrasts). If \code{FALSE}, the data set will be subset to the
#'     relevant samples for each comparison. Only applicable if
#'     \code{testType} is \code{"interaction"}.
#' @param subtractBaseline Logical scalar, whether to subtract the background/
#'     reference value for each feature in each batch before fitting the
#'     model. If \code{TRUE}, requires that a 'batch' column is available.
#' @param baselineGroup Character scalar representing the reference group.
#'     Only used if \code{subtractBaseline} is \code{TRUE}, in which case the
#'     abundance values for a given sample will be adjusted by subtracting the
#'     average value across all samples in the \code{baselineGroup} from the
#'     same batch as the original sample.
#' @param testType The testing approach to use, either \code{"interaction"}
#'     or \code{"welch"} (similar to the approach used by \code{MSstatsPTM}).
#' @param minNbrValidValues Numeric, the minimum number of valid values
#'     (must be met in both the protein and peptide objects) for a
#'     peptide to be used for statistical testing.
#' @param minlFC Numeric, minimum log fold change to test against (only used
#'     if \code{testType = "interaction"}).
#' @param volcanoAdjPvalThr Numeric, adjusted p-value threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoLog2FCThr Numeric, log-fold change threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoMaxFeatures Numeric, maximum number of significant features
#'     to label in the volcano plots.
#' @param volcanoFeaturesToLabel Character vector with features to always
#'     label in the volcano plots (regardless of significance).
#' @param addInteractiveVolcanos Logical scalar indicating whether to add
#'     interactive volcano plots to the html report. For experiments with
#'     many quantified features or many comparisons, setting this to
#'     \code{TRUE} can make the html report very large and difficult to
#'     interact with.
#' @param interactiveDisplayColumns Character vector (or \code{NULL})
#'     indicating which columns to include in the tooltip for the
#'     interactive volcano plots. The default shows the feature ID.
#' @param seed Numeric, random seed to use for any non-deterministic
#'     calculations.
#' @param linkTableColumns Character vector with regular expressions that will
#'     be matched against the column names of the rowData of the generated
#'     SingleCellExperiment object and included in the link table in the end
#'     of the report.
#' @param customYml Character string providing the path to a custom YAML file
#'     that can be used to overwrite default settings in the report. If set
#'     to \code{NULL} (default), no alterations are made.
#' @param doRender Logical scalar. If \code{FALSE}, the Rmd file will be
#'     generated (and any parameters injected), but not rendered.
#'
#' @export
#' @author Charlotte Soneson
#'
#' @return Invisibly, the path to the compiled html report.
#'
#' @importFrom xfun Rscript_call
#' @importFrom rmarkdown render
#' @importFrom readr read_file write_file
#' @importFrom grDevices pdf dev.off
#'
runPDTMTptmAnalysis <- function(
        templateRmd = system.file("extdata/process_PD_TMT_PTM_template.Rmd",
                                  package = "einprot"),
        outputDir = ".", outputBaseName = "PDTMTptmAnalysis",
        reportTitle = "PD/PTM data processing", reportAuthor = "",
        forceOverwrite = FALSE,
        experimentInfo = list(), species, sceProteins, scePeptides,
        assayForTests, assayImputation,
        proteinIdColProteins = function(df) einprot::getFirstId(df, "einprotProtein", ";"),
        proteinIdColPeptides = function(df) einprot::getFirstId(df, "einprotProtein", ";"),
        modificationsCol = "Modifications", excludeUnmodifiedPeptides = TRUE,
        keepModifications = NULL, comparisons = list(),
        ctrlGroup = "", allPairwiseComparisons = TRUE, singleFit = FALSE,
        subtractBaseline = FALSE, baselineGroup = "",
        testType = "interaction", minNbrValidValues = 2,
        minlFC = 0, volcanoAdjPvalThr = 0.05,
        volcanoLog2FCThr = 1, volcanoMaxFeatures = 25,
        volcanoFeaturesToLabel = "",
        addInteractiveVolcanos = FALSE, interactiveDisplayColumns = NULL,
        seed = 42, linkTableColumns = c(), customYml = NULL, doRender = TRUE
) {

    ## --------------------------------------------------------------------- ##
    ## Check arguments
    ## --------------------------------------------------------------------- ##
    .checkArgumentsPDTMTptm(
        templateRmd = templateRmd, outputDir = outputDir,
        outputBaseName = outputBaseName, reportTitle = reportTitle,
        reportAuthor = reportAuthor, forceOverwrite = forceOverwrite,
        experimentInfo = experimentInfo, species = species,
        sceProteins = sceProteins, scePeptides = scePeptides,
        assayForTests = assayForTests, assayImputation = assayImputation,
        proteinIdColProteins = proteinIdColProteins,
        proteinIdColPeptides = proteinIdColPeptides,
        modificationsCol = modificationsCol,
        excludeUnmodifiedPeptides = excludeUnmodifiedPeptides,
        keepModifications = keepModifications,
        comparisons = comparisons, ctrlGroup = ctrlGroup,
        allPairwiseComparisons = allPairwiseComparisons, singleFit = singleFit,
        subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
        testType = testType, minNbrValidValues = minNbrValidValues,
        minlFC = minlFC, volcanoAdjPvalThr = volcanoAdjPvalThr,
        volcanoLog2FCThr = volcanoLog2FCThr,
        volcanoMaxFeatures = volcanoMaxFeatures,
        volcanoFeaturesToLabel = volcanoFeaturesToLabel,
        addInteractiveVolcanos = addInteractiveVolcanos,
        interactiveDisplayColumns = interactiveDisplayColumns,
        seed = seed, linkTableColumns = linkTableColumns,
        customYml = customYml, doRender = doRender)

    ## If pandoc is not available, don't run it (just generate .md file)
    ## Gives a warning if pandoc and/or pandoc-citeproc is not available
    pandocOK <- .checkPandoc(ignorePandoc = TRUE)

    ## --------------------------------------------------------------------- ##
    ## Copy Rmd template and insert arguments
    ## --------------------------------------------------------------------- ##
    confighook <- "ConfigParameters"

    ## Concatenate Rmd chunk yml
    configchunk <- .generateConfigChunk(
        list(reportTitle = reportTitle, reportAuthor = reportAuthor,
             experimentInfo = experimentInfo, species = species,
             sceProteins = sceProteins, scePeptides = scePeptides,
             assayForTests = assayForTests, assayImputation = assayImputation,
             proteinIdColProteins = proteinIdColProteins,
             proteinIdColPeptides = proteinIdColPeptides,
             modificationsCol = modificationsCol,
             excludeUnmodifiedPeptides = excludeUnmodifiedPeptides,
             keepModifications = keepModifications,
             comparisons = comparisons, ctrlGroup = ctrlGroup,
             allPairwiseComparisons = allPairwiseComparisons, singleFit = singleFit,
             subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
             testType = testType, minNbrValidValues = minNbrValidValues,
             minlFC = minlFC, volcanoAdjPvalThr = volcanoAdjPvalThr,
             volcanoLog2FCThr = volcanoLog2FCThr,
             volcanoMaxFeatures = volcanoMaxFeatures,
             volcanoFeaturesToLabel = volcanoFeaturesToLabel,
             addInteractiveVolcanos = addInteractiveVolcanos,
             interactiveDisplayColumns = interactiveDisplayColumns,
             seed = seed, linkTableColumns = linkTableColumns,
             customYml = customYml, doRender = doRender)
    )

    ## Read Rmd
    rmd <- readr::read_file(templateRmd)

    ## Determine where to insert the config chunk
    ## From https://community.rstudio.com/t/how-to-write-r-script-into-rmd-as-functioning-code-chunk/37453/2
    header_regex <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
                            confighook,
                            confighook)

    ## Replace hooks with config chunk
    output <- gsub(header_regex, configchunk, rmd)

    ## Similarly, add any custom yaml
    ymlhook <- "YmlParameters"
    header_regex_yml <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
                                ymlhook,
                                ymlhook)
    if (!is.null(customYml)) {
        customYml <- paste(readLines(customYml), collapse = "\n")
    } else {
        customYml <- ""
    }
    output <- gsub(header_regex_yml, customYml, output)

    ## Write output to file
    if (!dir.exists(outputDir)) {
        dir.create(outputDir, recursive = TRUE)
    }
    outputFile <- file.path(outputDir, paste0(outputBaseName, ".Rmd"))
    if (file.exists(outputFile) && !forceOverwrite) {
        stop(outputFile, " already exists and forceOverwrite = FALSE, stopping.")
    } else if (file.exists(outputFile) && forceOverwrite) {
        message(outputFile, " already exists but forceOverwrite = TRUE, overwriting.")
    }
    readr::write_file(output, file = outputFile)

    ## --------------------------------------------------------------------- ##
    ## Render the Rmd file
    ## --------------------------------------------------------------------- ##
    args <- list()
    args$input <- outputFile
    args$output_format <- "html_document"
    args$output_dir <- outputDir
    args$intermediates_dir <- outputDir
    args$quiet <- FALSE
    args$run_pandoc <- pandocOK

    if (doRender) {
        #nocov start
        outputReport <- xfun::Rscript_call(
            rmarkdown::render,
            args
        )
        #nocov end
    } else {
        outputReport <- outputFile
    }

    ## --------------------------------------------------------------------- ##
    ## Return (invisibly) the path to the rendered html file
    ## --------------------------------------------------------------------- ##
    invisible(outputReport)
}
