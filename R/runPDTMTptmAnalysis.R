#' Run PTM analysis on PD/TMT data
#'
#' Launch an analysis workflow to detect post-translational modifications
#' based on outputs from separate protein- and peptide-level analyses run
#' with \code{runPDTMTAnalysis()}.
#'
#' @param templateRmd Path to the template R Markdown file. Typically does not
#'     need to be modified.
#' @param outputDir Path to a directory where all output files will be
#'     written. Will be created if it doesn't exist.
#' @param outputBaseName Character string providing the 'base name' of the
#'     output files. All output files will start with this prefix.
#' @param reportTitle,reportAuthor Character scalars, giving the title and
#'     author for the result report.
#' @param forceOverwrite Logical, whether to force overwrite an existing
#'     Rmd file with the same \code{outputBaseName} in the \code{outputDir}.
#' @param experimentInfo Named list with information about the experiment.
#'     Each entry of the list must be a scalar value.
#' @param species Character scalar providing the species. Must be one of the
#'     supported species (see \code{getSupportedSpecies()}). Either the common
#'     or the scientific name can be used.
#' @param sceProteins,scePeptides Character strings pointing to .rds files with
#'     \code{SingleCellExperiment} objects containing proteins and
#'     peptides, respectively and generated by \code{runPDTMTAnalysis()}.
#'     File paths will be expressed in canonical form (using
#'     \code{normalizePath()}) before they are processed.
#' @param assayForTests Character string giving the name of the assay to
#'     use for testing.
#' @param assayImputation Character string giving the name of the assay
#'     containing information about the imputation status of each observation.
#' @param idCol,labelCol Arguments defining the feature identifiers (row names,
#'     should be unique) and feature labels (for plots, can be anything).
#'     Each of these arguments can be either a character vector of column
#'     names in the input file (after application of \code{make.names}),
#'     in which case the corresponding feature ID
#'     is generated by simply concatenating the values in these columns, or a
#'     function with one input argument (a data.frame, corresponding to the
#'     annotation columns of the input file), returning a
#'     character vector corresponding to the desired feature IDs.
#' @param proteinIdColProteins,proteinIdColPeptides Character strings pointing
#'     to columns of the \code{rowData} of the respective objects that
#'     contain the protein identifiers (will be used to match the two objects).
#' @param comparisons List of character vectors defining comparisons to
#'     perform. The first element of each vector represents the
#'     denominator of the comparison. If not empty, \code{ctrlGroup} and
#'     \code{allPairwiseComparisons} are ignored.
#' @param ctrlGroup Character vector defining the sample group(s) to use as
#'     control group in comparisons.
#' @param allPairwiseComparisons Logical, should all pairwise comparisons be
#'     performed?
#' @param singleFit Logical scalar indicating whether a single model fit
#'     should be used (and results for pairwise comparisons extracted via
#'     contrasts). If \code{FALSE}, the data set will be subset to the
#'     relevant samples for each comparison. Only applicable if
#'     \code{testType} is \code{"interaction"}.
#' @param subtractBaseline Logical scalar, whether to subtract the background/
#'     reference value for each feature in each batch before fitting the
#'     model. If \code{TRUE}, requires that a 'batch' column is available.
#' @param baselineGroup Character scalar representing the reference group.
#'     Only used if \code{subtractBaseline} is \code{TRUE}, in which case the
#'     abundance values for a given sample will be adjusted by subtracting the
#'     average value across all samples in the \code{baselineGroup} from the
#'     same batch as the original sample.
#' @param testType The testing approach to use, either \code{"interaction"}
#'     or \code{"welch"} (similar to the approach used by \code{MSstatsPTM}).
#' @param minNbrValidValues Numeric, the minimum number of valid values
#'     (must be met in both the protein and peptide objects) for a
#'     peptide to be used for statistical testing.
#' @param minlFC Numeric, minimum log fold change to test against (only used
#'     if \code{testType = "interaction"}).
#' @param volcanoAdjPvalThr Numeric, adjusted p-value threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoLog2FCThr Numeric, log-fold change threshold to determine
#'     which proteins to highlight in the volcano plots.
#' @param volcanoMaxFeatures Numeric, maximum number of significant features
#'     to label in the volcano plots.
#' @param volcanoLabelSign Character scalar, either 'both', 'pos', or 'neg',
#'     indicating whether to label the most significant features regardless of
#'     sign, or only those with positive/negative log-fold changes.
#' @param volcanoFeaturesToLabel Character vector with features to always
#'     label in the volcano plots (regardless of significance).
#' @param addInteractiveVolcanos Logical scalar indicating whether to add
#'     interactive volcano plots to the html report. For experiments with
#'     many quantified features or many comparisons, setting this to
#'     \code{TRUE} can make the html report very large and difficult to
#'     interact with.
#' @param interactiveDisplayColumns Character vector (or \code{NULL})
#'     indicating which columns to include in the tooltip for the
#'     interactive volcano plots. The default shows the feature ID.
#' @param interactiveGroupColumn Character scalar (or \code{NULL}, default)
#'     indicating the column to group points by in the interactive volcano
#'     plot. Hovering over a point will highlight all other points with the
#'     same value of this column.
#' @param seed Numeric, random seed to use for any non-deterministic
#'     calculations.
#' @param linkTableColumns Character vector with regular expressions that will
#'     be matched against the column names of the rowData of the generated
#'     SingleCellExperiment object and included in the link table in the end
#'     of the report.
#' @param customYml Character string providing the path to a custom YAML file
#'     that can be used to overwrite default settings in the report. If set
#'     to \code{NULL} (default), no alterations are made.
#' @param doRender Logical scalar. If \code{FALSE}, the Rmd file will be
#'     generated (and any parameters injected), but not rendered.
#'
#' @export
#' @author Charlotte Soneson
#'
#' @returns Invisibly, the path to the compiled html report.
#'
#' @importFrom xfun Rscript_call
#' @importFrom rmarkdown render
#' @importFrom readr read_file write_file
#' @importFrom SummarizedExperiment rowData assayNames
#' @importFrom DT datatable
#' @importFrom ExploreModelMatrix VisualizeDesign
#' @importFrom cowplot plot_grid
#' @importFrom htmltools tagList
#' @importFrom knitr current_input
#' @importFrom dplyr %>% select rename matches filter arrange desc between
#' @importFrom ComplexUpset upset
#' @importFrom tibble rownames_to_column
#' @importFrom ggplot2 ggplot aes geom_abline theme_bw labs theme
#'     element_text geom_point ggtitle
#' @importFrom ggrepel geom_text_repel
#'
runPDTMTptmAnalysis <- function(
        templateRmd = system.file("extdata/process_PD_TMT_PTM_template.Rmd",
                                  package = "einprot"),
        outputDir = ".", outputBaseName = "PDTMTptmAnalysis",
        reportTitle = "PD/PTM data processing", reportAuthor = "",
        forceOverwrite = FALSE,
        experimentInfo = list(), species, sceProteins, scePeptides,
        assayForTests, assayImputation, idCol, labelCol,
        proteinIdColProteins = function(df) einprot::getFirstId(df, "einprotProtein", ";"),
        proteinIdColPeptides = function(df) einprot::getFirstId(df, "einprotProtein", ";"),
        comparisons = list(),
        ctrlGroup = "", allPairwiseComparisons = TRUE, singleFit = TRUE,
        subtractBaseline = FALSE, baselineGroup = "",
        testType = "interaction", minNbrValidValues = 2,
        minlFC = 0, volcanoAdjPvalThr = 0.05,
        volcanoLog2FCThr = 1, volcanoMaxFeatures = 25,
        volcanoLabelSign = "both",
        volcanoFeaturesToLabel = "",
        addInteractiveVolcanos = FALSE, interactiveDisplayColumns = NULL,
        interactiveGroupColumn = NULL,
        seed = 42, linkTableColumns = c(), customYml = NULL, doRender = TRUE
) {
    ## -------------------------------------------------------------------------
    ## Check arguments
    ## -------------------------------------------------------------------------
    .checkArgumentsPDTMTptm(
        templateRmd = templateRmd, outputDir = outputDir,
        outputBaseName = outputBaseName, reportTitle = reportTitle,
        reportAuthor = reportAuthor, forceOverwrite = forceOverwrite,
        experimentInfo = experimentInfo, species = species,
        sceProteins = sceProteins, scePeptides = scePeptides,
        assayForTests = assayForTests, assayImputation = assayImputation,
        idCol = idCol, labelCol = labelCol,
        proteinIdColProteins = proteinIdColProteins,
        proteinIdColPeptides = proteinIdColPeptides,
        comparisons = comparisons, ctrlGroup = ctrlGroup,
        allPairwiseComparisons = allPairwiseComparisons, singleFit = singleFit,
        subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
        testType = testType, minNbrValidValues = minNbrValidValues,
        minlFC = minlFC, volcanoAdjPvalThr = volcanoAdjPvalThr,
        volcanoLog2FCThr = volcanoLog2FCThr,
        volcanoMaxFeatures = volcanoMaxFeatures,
        volcanoLabelSign = volcanoLabelSign,
        volcanoFeaturesToLabel = volcanoFeaturesToLabel,
        addInteractiveVolcanos = addInteractiveVolcanos,
        interactiveDisplayColumns = interactiveDisplayColumns,
        interactiveGroupColumn = interactiveGroupColumn,
        seed = seed, linkTableColumns = linkTableColumns,
        customYml = customYml, doRender = doRender)

    ## If pandoc is not available, don't run it (just generate .md file)
    ## Gives a warning if pandoc and/or pandoc-citeproc is not available
    pandocOK <- .checkPandoc(ignorePandoc = TRUE)

    ## -------------------------------------------------------------------------
    ## Normalize paths
    ## -------------------------------------------------------------------------
    sceProteins <- normalizePath(sceProteins)
    scePeptides <- normalizePath(scePeptides)

    ## -------------------------------------------------------------------------
    ## Copy Rmd template and insert arguments
    ## -------------------------------------------------------------------------
    confighook <- "ConfigParameters"

    ## Concatenate Rmd chunk yml
    configchunk <- .generateConfigChunk(
        list(reportTitle = reportTitle, reportAuthor = reportAuthor,
             experimentInfo = experimentInfo, species = species,
             sceProteins = sceProteins, scePeptides = scePeptides,
             assayForTests = assayForTests, assayImputation = assayImputation,
             idCol = idCol, labelCol = labelCol,
             proteinIdColProteins = proteinIdColProteins,
             proteinIdColPeptides = proteinIdColPeptides,
             comparisons = comparisons, ctrlGroup = ctrlGroup,
             allPairwiseComparisons = allPairwiseComparisons,
             singleFit = singleFit,
             subtractBaseline = subtractBaseline, baselineGroup = baselineGroup,
             testType = testType, minNbrValidValues = minNbrValidValues,
             minlFC = minlFC, volcanoAdjPvalThr = volcanoAdjPvalThr,
             volcanoLog2FCThr = volcanoLog2FCThr,
             volcanoMaxFeatures = volcanoMaxFeatures,
             volcanoLabelSign = volcanoLabelSign,
             volcanoFeaturesToLabel = volcanoFeaturesToLabel,
             addInteractiveVolcanos = addInteractiveVolcanos,
             interactiveDisplayColumns = interactiveDisplayColumns,
             interactiveGroupColumn = interactiveGroupColumn,
             seed = seed, linkTableColumns = linkTableColumns,
             customYml = customYml, doRender = doRender)
    )

    ## Read Rmd
    rmd <- readr::read_file(templateRmd)

    ## Determine where to insert the config chunk
    ## From https://community.rstudio.com/t/how-to-write-r-script-into-rmd-as-functioning-code-chunk/37453/2
    # header_regex <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
    #                         confighook,
    #                         confighook)
    header_regex <- sprintf("{{%sStart}}\n\n{{%sEnd}}",
                            confighook,
                            confighook)

    ## Replace hooks with config chunk
    output <- sub(header_regex, configchunk, rmd, fixed = TRUE)

    ## Similarly, add any custom yaml
    ymlhook <- "YmlParameters"
    # header_regex_yml <- sprintf("\\{\\{%sStart\\}\\}(.*?)\\{\\{%sEnd\\}\\}",
    #                             ymlhook,
    #                             ymlhook)
    header_regex_yml <- sprintf("{{%sStart}}\n\n{{%sEnd}}",
                                ymlhook,
                                ymlhook)
    if (!is.null(customYml)) {
        customYml <- paste(readLines(customYml), collapse = "\n")
    } else {
        customYml <- ""
    }
    output <- sub(header_regex_yml, customYml, output, fixed = TRUE)

    ## Write output to file
    if (!dir.exists(outputDir)) {
        dir.create(outputDir, recursive = TRUE)
    }
    outputFile <- file.path(outputDir, paste0(outputBaseName, ".Rmd"))
    if (file.exists(outputFile) && !forceOverwrite) {
        stop(outputFile,
             " already exists and forceOverwrite = FALSE, stopping.")
    } else if (file.exists(outputFile) && forceOverwrite) {
        message(outputFile,
                " already exists but forceOverwrite = TRUE, overwriting.")
    }
    readr::write_file(output, file = outputFile)

    ## -------------------------------------------------------------------------
    ## Render the Rmd file
    ## -------------------------------------------------------------------------
    args <- list()
    args$input <- outputFile
    args$output_format <- "html_document"
    args$output_dir <- outputDir
    args$intermediates_dir <- outputDir
    args$quiet <- FALSE
    args$run_pandoc <- pandocOK

    if (doRender) {
        #nocov start
        outputReport <- xfun::Rscript_call(
            rmarkdown::render,
            args
        )
        #nocov end
    } else {
        outputReport <- outputFile
    }

    ## -------------------------------------------------------------------------
    ## Return (invisibly) the path to the rendered html file
    ## -------------------------------------------------------------------------
    invisible(outputReport)
}
