{{YmlParametersStart}}

{{YmlParametersEnd}}

---
date: "`r paste0(format(Sys.time(), '%F %T %Z'), ' (einprot v', packageVersion('einprot'), ')')`"
output: 
    html_document:
        theme: united
        toc: true
        toc_float: true
        code_folding: hide
editor_options: 
  chunk_output_type: console
bibliography: "`r system.file('extdata', 'einprot_bibliography.bib', package = 'einprot')`"
---

{{ConfigParametersStart}}

{{ConfigParametersEnd}}

---
title: "`r reportTitle`"
author: "`r reportAuthor`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi = 200)
```

```{r load-pkg, echo=FALSE}
## Load packages
suppressPackageStartupMessages({
    library(STRINGdb)
    library(SummarizedExperiment)
    library(DT)
    library(limma)
    library(ExploreModelMatrix)
    library(cowplot)
    library(htmltools)
    library(dplyr)
    library(ComplexUpset)
    library(ggplot2)
    library(tibble)
    library(S4Vectors)
    library(scater)
    library(SingleCellExperiment)
    library(BiocSingular)
    library(ggalt)
    library(plotly)
    library(ComplexHeatmap)
    library(einprot)
})
```

```{r text-intro, results="asis", echo=FALSE}
cat(introText(expType = expType))
```

Most of the code is hidden by default, 
but can be displayed by clicking on the `Show` buttons (or by selecting 
`Code -> Show All Code` in the top right corner of the report).
Navigation between the different sections can be done via the table of 
contents in the left sidebar. 
In the first part of the report, the quantified data is read into R and 
passed through a range of processing and quality control steps. These are 
followed by [statistical analysis](#volcano-plots) to find and visualize 
differentially abundant features. A [summary table](#linktable) provides direct 
links to external resources, and an additional global overview 
of the data is provided via [principal component analysis](#run-pca).

```{r get-basic-info}
## Get species info and define STRINGdb object
speciesInfo <- getSpeciesInfo(species)
if (expType %in% c("MaxQuant", "FragPipe", "DIANN", "Spectronaut") || 
    (expType == "ProteomeDiscoverer" && inputLevel == "Proteins")) {
    if (is.null(stringDir)) stringDir <- ""
    if (is.null(stringIdCol) || is.na(speciesInfo$taxId)) {
        ## If no STRING IDs are extracted or an unknown species is provided, 
        ## don't do STRING analysis
        string_db <- NULL
    } else {
        string_db <- tryCatch({
            tmp <- STRINGdb$new(version = stringVersion, species = speciesInfo$taxId, 
                                score_threshold = 400, input_directory = stringDir)
            if (!exists("tmp")) {
                warning("The STRINGdb object can not be created. ", 
                        "No STRING analysis will be performed.", 
                        call. = FALSE)
                tmp <- NULL
            } else {
                print(tmp)
            }
            tmp
        }, error = function(e) {
            warning("The STRINGdb object can not be created. ", 
                    "No STRING analysis will be performed.", 
                    call. = FALSE)
            NULL
        })
    }
} else {
    string_db <- NULL
}

## If needed and not provided, define path to complex DB 
## (will be added to summary table below)
if ("complexes" %in% includeFeatureCollections && is.null(complexDbPath)) {
    complexDbPath <- system.file(EINPROT_COMPLEXES_FILE,
                                 package = "einprot")
}

## Get conversion tables for PomBase and WormBase IDs
pbconv <- readRDS(system.file(EINPROT_POMBASE_CONVTABLE,
                              package = "einprot"))
wbconv <- readRDS(system.file(EINPROT_WORMBASE_CONVTABLE,
                              package = "einprot"))
```

# Experiment details

```{r exp-table}
makeTableFromList(c(experimentInfo, 
                    list(
                        "Species" = speciesInfo$species,
                        "Species (common)" = speciesInfo$speciesCommon,
                        "Taxonomic ID" = speciesInfo$taxId
                    )))
```

# Analysis summary

```{r run-table}
if (expType == "MaxQuant") {
    tb <- readMaxQuantXML(mqParameterFile)
    tb <- c(list("MaxQuant file" = mqFile), tb)
} else if (expType == "ProteomeDiscoverer") {
    tb <- readProteomeDiscovererInfo(pdOutputFolder, pdResultName, 
                                     pdAnalysisFile)
    pdFile <- file.path(pdOutputFolder, paste0(pdResultName, "_", inputLevel, ".txt"))
    tb <- c(list("PD quantification file" = pdFile), tb)
} else if (expType == "FragPipe") {
    tb <- readFragPipeInfo(fragpipeDir)
    tb <- c(list("Protein file" = file.path(fragpipeDir, "combined_protein.tsv")), tb)
} else if (expType == "DIANN") {
    dia <- readDIANNInfo(diannLogFile)
    dia <- c(list("DIA-NN file" = diannFile, 
                  "File type" = diannFileType, 
                  "Analysis level" = outLevel), dia)
    tb <- dia[names(dia) != "DIA-NN command"]
} else if (expType == "Spectronaut") {
    tb <- list("Spectronaut file" = spectronautFile,
               "Spectronaut log file" = spectronautLogFile,
               "Analysis level" = outLevel)
} else {
    stop("Unknown 'expType'")
}

makeTableFromList(tb)
```

# Settings {#settings-table}

```{r settings-table}
settingsList <- list(
    "Include only samples (if applicable)" = paste(includeOnlySamples, 
                                                   collapse = ", "),
    "Exclude samples" = paste(excludeSamples, collapse = ", "),
    "Min. number of peptides" = minPeptides,
    "Min. protein score" = minScore,
    "Imputation method" = imputeMethod,
    "Assays(s) to use for exported values" = paste(assaysForExport, collapse = ", "), 
    "Show heatmaps" = addHeatmaps,
    "Min. nbr valid values required for testing" = minNbrValidValues,
    "Model fit" = ifelse(singleFit, "Single (one model fit for all samples)", 
                         "Separate model fit for each comparison"),
    "Groups to merge" = paste(unlist(
        lapply(names(mergeGroups), 
               function(nm) paste0(nm, ":", paste(mergeGroups[[nm]], collapse = ",")))),
        collapse = "; "),
    "Comparisons" = paste(unlist(lapply(comparisons, 
                                        function(x) paste(x, collapse = " vs "))),
                          collapse = "; "),
    "Control group" = ctrlGroup,
    "Do all pairwise comparisons" = allPairwiseComparisons,
    "Batch correction via baseline subtraction" = subtractBaseline,
    "Baseline group" = baselineGroup,
    "Normalization method" = normMethod,
    "Spike features" = paste(spikeFeatures, collapse = ","),
    "Statistical test" = stattest,
    "Minimal fold change (limma/treat)" = minlFC,
    "Adjusted p-value threshold for volcano plots" = volcanoAdjPvalThr,
    "Log2 FC threshold for volcano plots" = volcanoLog2FCThr,
    "Max nbr features to indicate in volcano plots" = volcanoMaxFeatures,
    "Sign of features to indicate in volcano plots" = volcanoLabelSign,
    "Use SAM statistic for significance" = samSignificance,
    "s0" = volcanoS0,
    "Features to always label in volcano plots" = paste(volcanoFeaturesToLabel,
                                                        collapse = ", "),
    "Feature collections for enrichment testing" = paste(includeFeatureCollections, collapse = "; "),
    "Minimal required size for feature sets" = minSizeToKeepSet,
    "Complexes file" = gsub(".+\\/(.+.rds)", "\\1", complexDbPath),
    "Complexes from species" = complexSpecies,
    "Custom complexes" = paste(names(customComplexes), collapse = ";"),
    "FDR Threshold for complexes" = complexFDRThr,
    "Max nbr complexes to plot" = maxNbrComplexesToPlot,
    "Number of permutations" = nperm,
    "Random seed" = seed,
    "Columns to add in link table" = paste(linkTableColumns, collapse = ";"),
    "Interactive display columns" = paste(interactiveDisplayColumns, collapse = ";"),
    "Interactive group column" = interactiveGroupColumn
)

if (stattest == "ttest") {
    settingsList <- settingsList[!(names(settingsList) %in% 
                                       c("Minimal fold change (limma/treat)",
                                         "Log2 FC threshold for volcano plots"))]
}
if (stattest %in% c("limma", "proDA")) {
    settingsList <- settingsList[!(names(settingsList) %in% 
                                       c("s0", "Number of permutations", 
                                         "Use SAM statistic for significance"))]
}

## Tool-specific adaptations
if (expType %in% c("MaxQuant", "FragPipe", "ProteomeDiscoverer")) {
    settingsList <- c(list("Column pattern" = iColPattern), 
                      settingsList)
}
if (expType == "ProteomeDiscoverer") {
    settingsList <- c(settingsList, 
                      list("Input type" = inputLevel,
                           "Min. number of PSMs" = minPSMs, 
                           "Min. delta score" = minDeltaScore,
                           "Only retain master proteins" = masterProteinsOnly,
                           "Modifications column" = modificationsCol,
                           "Exclude unmodified peptides" = excludeUnmodifiedPeptides,
                           "Modifications to keep" = paste(keepModifications, collapse = ", ")))
    if (inputLevel == "Proteins") {
        settingsList <- settingsList[!(names(settingsList) %in% 
                                           c("Min. number of PSMs",
                                             "Min. delta score"))]
    }
    if (inputLevel == "PeptideGroups") {
        settingsList <- settingsList[!(names(settingsList) %in%
                                           c("Min. number of peptides",
                                             "Min. protein score", 
                                             "Only retain master proteins"))]
    }
}

makeTableFromList(settingsList)
```


# Read quantification output

```{r text-input, results="asis", echo=FALSE}
if (expType == "ProteomeDiscoverer") {
    cat(inputText(expTypeLevel = paste0(expType, inputLevel)))
} else {
    cat(inputText(expTypeLevel = expType))
}
```

This object will later be expanded with additional data, such as 
transformed and imputed abundances. 

At this point, the SingleCellExperiment object holds assays with the different 
types of intensities and annotations from the input file.

```{r read-data}
if (expType == "MaxQuant") {
    ## Read MaxQuant output
    tmp <- importExperiment(inFile = mqFile, iColPattern = iColPattern,
                            includeOnlySamples = includeOnlySamples,
                            excludeSamples = excludeSamples)
} else if (expType == "FragPipe") {
    ## Read FragPipe output
    tmp <- importExperiment(inFile = file.path(fragpipeDir, "combined_protein.tsv"),
                            iColPattern = iColPattern,
                            includeOnlySamples = includeOnlySamples,
                            excludeSamples = excludeSamples)
} else if (expType == "ProteomeDiscoverer") {
    ## Read Proteome Discoverer output
    tmp <- importExperiment(inFile = pdFile, iColPattern = iColPattern,
                            includeOnlySamples = includeOnlySamples,
                            excludeSamples = excludeSamples)
} else if (expType == "DIANN") {
    ## Read DIA-NN output
    tmp <- importDIANN(inFile = diannFile, fileType = diannFileType, 
                       outLevel = outLevel,
                       stopIfEmpty = FALSE, aName = aName,
                       includeOnlySamples = includeOnlySamples,
                       excludeSamples = excludeSamples)
} else if (expType == "Spectronaut") {
    ## Read Spectronaut output
    tmp <- importSpectronaut(inFile = spectronautFile, outLevel = outLevel, 
                             stopfIfEmpty = FALSE, aName = aName, 
                             includeOnlySamples = includeOnlySamples, 
                             excludeSamples = excludeSamples)
} else {
    stop("Unknown 'expType'")
}

sce <- tmp$sce
aName <- tmp$aName

sce
```

<details>
<summary><b>
Click to see which columns from the input file were used to form each of the 
assays in the `SingleCellExperiment` object.
</b></summary>
```{r col-list}
S4Vectors::metadata(sce)$colList
```
</details>

# Add sample annotations

Next, we compile the sample annotations. The sample IDs have been extracted 
from the column names in the input file. The `group` 
column will be used to define groups for the statistical testing later. If 
a `batch` column is present, that will also be accounted for in the 
`limma` model. See the [Comparisons and design](#comparisons-and-design) 
section below for more details 
about the fitted model(s). Please check that the table below correspond to 
your expectations.

```{r add-sampleinfo}
sce <- addSampleAnnots(sce, sampleAnnot = sampleAnnot)

DT::datatable(as.data.frame(colData(sce)),
              options = list(scrollX = TRUE, pageLength = 20))
```

# Overview of the workflow

We already now define the names of the assays we will be generating 
and using later in the workflow. 

```{r define-assaynames}
aNames <- defineAssayNames(aName = aName, normMethod = normMethod, 
                           doBatchCorr = "batch" %in% colnames(colData(sce)))
makeTableFromList(aNames)
```

The figure below provides a high-level overview of the workflow, and where 
the assays defined above will be generated. 
Note that depending on the settings specified by the user, not all steps may 
be performed (this is typically indicated by multiple assay names in the table 
above being equal).

```{r overview-graph}
knitr::include_graphics(system.file("extdata", "einprot_workflow.png", 
                                    package = "einprot"))
```


# Overall distribution of feature intensities

The box plot below displays the distribution of raw feature intensities in 
each sample (if applicable), on a log scale (excluding any missing values), 
as well as the values in the input assay defined above.

```{r intensity-distribution, warning=FALSE, message=FALSE, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 5/7 * min(14, max(7, 0.5 * ncol(sce)))}
if ("Intensity" %in% assayNames(sce)) {
    print(makeIntensityBoxplots(sce = sce, assayName = "Intensity", 
                                doLog = TRUE, ylab = "Intensity"))
}
makeIntensityBoxplots(sce = sce, assayName = aNames$assayInput, doLog = TRUE, 
                      ylab = aNames$assayInput)
```

# Filter out contaminants, reverse hits, and features with low confidence

Next, we filter out any features classified as potential 
contaminants or reverse (decoy) hits, and features identified only by site (which 
removes proteins that are only identified by peptides carrying one or more 
modified amino acids). In addition, we may remove protein identifications 
based on score and number of peptides (i.e. to exclude one-hit wonders). 
The excluded features, together with the available annotations, are written to 
a text file. 
The UpSet plot below illustrates the overlaps between the sets of features 
filtered out based on the different criteria (vertical bars). 

```{r filter-features}
nbrFeaturesBefore <- nrow(sce)
if (expType == "MaxQuant") {
    sce <- filterMaxQuant(sce = sce, minScore = minScore, minPeptides = minPeptides, 
                          plotUpset = TRUE, 
                          exclFile = sub("\\.Rmd$", paste0("_filtered_out_features.txt"), knitr::current_input(dir = TRUE)))
} else if (expType == "FragPipe") {
    sce <- filterFragPipe(sce = sce, minPeptides = minPeptides, 
                          plotUpset = TRUE, 
                          revPattern = paste0("^", tb[["Database decoy tag"]]),
                          exclFile = sub("\\.Rmd$", paste0("_filtered_out_features.txt"), knitr::current_input(dir = TRUE)))
} else if (expType == "ProteomeDiscoverer") {
    sce <- filterPDTMT(sce = sce, inputLevel = inputLevel, minScore = minScore, 
                       minPeptides = minPeptides, minDeltaScore = minDeltaScore, 
                       minPSMs = minPSMs, masterProteinsOnly = masterProteinsOnly, 
                       modificationsCol = modificationsCol, 
                       excludeUnmodifiedPeptides = excludeUnmodifiedPeptides, 
                       keepModifications = keepModifications, plotUpset = TRUE, 
                       exclFile = sub("\\.Rmd$", paste0("_filtered_out_features.txt"), knitr::current_input(dir = TRUE)))
} else if (expType == "Spectronaut") {
    sce <- sce
} else if (expType == "DIANN") {
    sce <- sce
} else {
    stop("Unknown 'expType'")
}

nbrFeaturesAfter <- nrow(sce)
if (nbrFeaturesAfter == 0) {
    stop("No features left after filtering!")
}
```

This filtering removed `r nbrFeaturesBefore - nbrFeaturesAfter` features. 
The new `sce` object has `r nbrFeaturesAfter` features.

# Modify feature names

The feature ID used when reading the data above are numeric indices. 
We replace these IDs with more interpretable ones, defined by the 
`idCol` argument. We also add columns holding gene IDs (if applicable), 
protein IDs, IDs for matching to STRING (if applicable) and IDs for labelling 
points in plots. 

```{r fix-ids}
sce <- fixFeatureIds(
    sce, 
    colDefs = list(einprotId = idCol, einprotLabel = labelCol,
                   einprotGene = geneIdCol, einprotProtein = proteinIdCol,
                   IDsForSTRING = stringIdCol)
)
if (any(duplicated(rowData(sce)[["einprotId"]]))) {
    stop("The 'einprotId' column cannot have duplicated entries.")
}
rownames(sce) <- rowData(sce)[["einprotId"]]
```

<details>
<summary><b>
Click to see examples of the defined feature identifiers
</b></summary>
```{r feature-id-overview-1, echo=FALSE}
rbind(
    head(as.data.frame(rowData(sce)[, c("einprotId", "einprotGene", "einprotProtein",
                                        "einprotLabel", "IDsForSTRING")]),
         n = min(5, floor(nrow(sce) / 2))),
    rep("...", 5),
    tail(as.data.frame(rowData(sce)[, c("einprotId", "einprotGene", "einprotProtein",
                                        "einprotLabel", "IDsForSTRING")]),
         n = min(5, floor(nrow(sce) / 2))), 
    make.row.names = FALSE
)
```
</details>

# Prepare feature collections for later testing

In addition to testing individual features for differential abundance 
between groups, we can also test collections of features. Here we 
define the collections that will be used. 

```{r prepare-feature-collections}
if (is.null(geneIdCol)) {
    ## If no gene IDs are extracted, don't compare to feature collections
    featureCollections <- list()
} else {
    (featureCollections <- prepareFeatureCollections(
        sce = sce, idCol = "einprotGene", 
        includeFeatureCollections = includeFeatureCollections,
        complexDbPath = complexDbPath, speciesInfo = speciesInfo,
        complexSpecies = complexSpecies, customComplexes = customComplexes,
        minSizeToKeep = minSizeToKeepSet))
}

## Remove collections without any sets
featureCollections <- featureCollections[lapply(featureCollections, length) > 0]
```

# Apply a log2 transformation

Before the downstream analysis, we log2-transform the measured intensities. We also 
add an additional assay to keep track of the position of the missing values
(which will be imputed later). 

```{r log-transform}
assay(sce, aNames$assayLog2WithNA) <- log2(assay(sce, aNames$assayInput))

## Add assay indicating missing values, which will be imputed
assay(sce, aNames$assayImputIndic) <- !is.finite(assay(sce, aNames$assayLog2WithNA))
sce
```

# Visualize missing value patterns

The plot below shows the fraction of the total set of features that are detected 
(with a non-missing value) in each of the samples.

```{r missing-values, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 5/7 * min(14, max(7, 0.5 * ncol(sce)))}
## Replace zeros/-Inf values by explicit NA values in the assays
assay(sce, aNames$assayInput)[assay(sce, aNames$assayInput) == 0] <- NA
assay(sce, aNames$assayLog2WithNA)[!is.finite(assay(sce, aNames$assayLog2WithNA))] <- NA

## Count number of NA values and add to SCE
colData(sce)$nNA <- colSums(is.na(assay(sce, aNames$assayInput)))
colData(sce)$pNA <- 100 * sce$nNA/nrow(sce)
rowData(sce)$nNA <- rowSums(is.na(assay(sce, aNames$assayInput)))
rowData(sce)$pNA <- 100 * rowData(sce)$nNA/ncol(sce)

plotFractionDetectedPerSample(dfNA = as.data.frame(colData(sce)[, c("sample", "nNA", "pNA")]))
```

We also plot the number of features that are detected in a given number 
of samples.

```{r missing-values-2, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 5/7 * min(14, max(7, 0.5 * ncol(sce)))}
plotDetectedInSamples(dfNA = as.data.frame(rowData(sce)[, c("nNA", "pNA")]))
```

Finally we show the full missing value structure in the data matrix. The white 
values correspond to missing values, and the grey ones to observed intensities.

```{r missing-values-overall, fig.height=7, message=FALSE, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 9/7 * min(14, max(7, 0.5 * ncol(sce)))}
if (addHeatmaps) {
    plotMissingValuesHeatmap(sce, assayMissing = aNames$assayImputIndic)
}
```

```{r no-features-text, results="asis", echo=FALSE}
cat(emptySampleText(sce = sce, assayName = aNames$assayLog2WithNA))
```

```{r remove-samples-with-no-features}
## Remove samples with no detected features (all values are NA)
no_feats <- which(colSums(!is.na(assay(sce, aNames$assayLog2WithNA))) == 0)
if (length(no_feats) > 0) {
    sce <- sce[, -no_feats]
}
```

```{r text-norm, results="asis", echo=FALSE}
cat(normText(normMethod = normMethod))
```

```{r normalize, echo=(normMethod != "none"), eval=(normMethod != "none"), message=FALSE, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 5/7 * min(14, max(7, 0.5 * ncol(sce)))}
sce <- doNormalization(sce, method = normMethod, 
                       assayName = aNames$assayLog2WithNA,
                       normalizedAssayName = aNames$assayLog2NormWithNA, 
                       spikeFeatures = spikeFeatures)

makeIntensityBoxplots(sce = sce, assayName = aNames$assayLog2NormWithNA,
                      doLog = FALSE, 
                      ylab = aNames$assayLog2NormWithNA)
```

# Imputation

Next, we apply the `r imputeMethod` method to perform imputation 
of the log2-transformed data, and plot the distribution of imputed and 
non-imputed values in each sample.

```{r plot-imputation, message = FALSE, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = min(14, max(7, 0.5 * ncol(sce)))}
set.seed(seed)
sce <- doImputation(sce, method = imputeMethod, 
                    assayName = aNames$assayLog2NormWithNA,
                    imputedAssayName = aNames$assayImputed)
plotImputationDistribution(sce, assayToPlot = aNames$assayImputed, 
                           assayImputation = aNames$assayImputIndic,
                           xlab = aNames$assayImputed)
```

# Overall distribution of log2 feature intensities

Next we consider the overall distribution of log2-intensities among the 
samples (after imputation).

```{r intensity-distribution-imputed, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 5/7 * min(14, max(7, 0.5 * ncol(sce)))}
makeIntensityBoxplots(sce = sce, assayName = aNames$assayImputed,
                      doLog = FALSE, 
                      ylab = aNames$assayImputed)
```


```{r remove-batch-effect}
if ("batch" %in% colnames(colData(sce))) {
    if (subtractBaseline) {
        assay(sce, aNames$assayBatchCorr) <- 
            getMatSubtractedBaseline(sce, assayName = aNames$assayImputed, 
                                     baselineGroup = baselineGroup, 
                                     sceFull = sce)
    } else {
        assay(sce, aNames$assayBatchCorr) <- 
            removeBatchEffect(assay(sce, aNames$assayImputed), 
                              batch = sce$batch, 
                              design = model.matrix(~ sce$group))
    }
}
```

# Statistical testing

```{r text-test, results="asis", echo=FALSE}
cat(testText(testType = stattest, minlFC = minlFC, 
             samSignificance = samSignificance))
```

## Comparisons and design

```{r set-test-assay}
## Set the assay to use for tests later
if (stattest == "proDA") {
    assayForTests <- aNames$assayLog2NormWithNA
} else {
    assayForTests <- aNames$assayImputed
}
```

The `r assayForTests` assay will be used for the tests. The 
following pairwise comparisons will be performed (in each case, the 
first listed group will be the 'baseline' group): 

```{r initialize-tests}
if (subtractBaseline) {
    discardGroup <- baselineGroup
} else {
    discardGroup <- NULL
}
if (stattest == "none") {
    comparisonList <- list(comparisons = list(),
                           groupComposition = list())
} else {
    comparisonList <- makeListOfComparisons(
        allGroups = unique(sce$group), comparisons = comparisons, 
        mergeGroups = mergeGroups, 
        allPairwiseComparisons = allPairwiseComparisons,
        ctrlGroup = ctrlGroup, discardGroup = discardGroup)
}
```

<details>
<summary><b>
Click to expand list of comparisons
</b></summary>
```{r list-of-comparisons}
comparisonList$comparisons
```
</details>

<details>
<summary><b>
Click to expand list of group compositions
</b></summary>
```{r list-of-group-compositions}
comparisonList$groupComposition
```
</details>

```{r no-test, eval = (stattest == "none"), echo = (stattest == "none")}
testres <- list()
tests <- list()
```

```{r def-aval}
if (any(assaysForExport %in% assayNames(sce))) {
    assaysForExport <- intersect(assaysForExport, assayNames(sce))
} else {
    assaysForExport <- aNames$assayInput
}
```

```{r run-test, eval = (stattest != "none"), echo = (stattest != "none")}
testres <- runTest(sce = sce, comparisons = comparisonList$comparisons,
                   groupComposition = comparisonList$groupComposition, 
                   testType = stattest, 
                   assayForTests = assayForTests,
                   assayImputation = aNames$assayImputIndic, 
                   minNbrValidValues = minNbrValidValues,
                   minlFC = minlFC, featureCollections = featureCollections, 
                   complexFDRThr = complexFDRThr,
                   volcanoAdjPvalThr = volcanoAdjPvalThr, 
                   volcanoLog2FCThr = volcanoLog2FCThr,
                   baseFileName = sub("\\.Rmd$", "", knitr::current_input()),
                   seed = seed, samSignificance = samSignificance, 
                   nperm = nperm, volcanoS0 = volcanoS0, 
                   aName = assaysForExport, addAbundanceValues = TRUE, 
                   singleFit = singleFit,
                   subtractBaseline = subtractBaseline, 
                   baselineGroup = baselineGroup, 
                   extraColumns = union(interactiveDisplayColumns,
                                        interactiveGroupColumn))

for (cmp in names(comparisonList$comparisons)) {
    ## Add WormBase/PomBase IDs if applicable
    if (speciesInfo$speciesCommon == "roundworm") {
        testres$tests[[cmp]]$WormBaseID <- 
            vapply(testres$tests[[cmp]][["einprotProtein"]],
                   function(mpds) {
                       wbids <- unlist(lapply(strsplit(mpds, ";")[[1]], function(mpd) {
                           wbconv$WormBaseID[wbconv$UniProtKB.ID == mpd |
                                                 wbconv$UniProtID == mpd]
                       }))
                       if (length(wbids[!is.na(wbids)]) != 0 && 
                           length(setdiff(wbids[!is.na(wbids)], "")) != 0) {
                           wbids <- setdiff(wbids, "")
                           wbids <- wbids[!is.na(wbids)]
                           paste(wbids, collapse = ";")
                       } else {
                           ""
                       }
                   }, "NA")
    } else if (speciesInfo$speciesCommon == "fission yeast") {
        testres$tests[[cmp]]$PomBaseID <- 
            vapply(testres$tests[[cmp]][["einprotProtein"]], 
                   function(mpds) {
                       pbids <- unlist(lapply(strsplit(mpds, ";")[[1]], function(mpd) {
                           pbconv$PomBaseID[pbconv$UniProtID == mpd]
                       }))
                       if (length(pbids[!is.na(pbids)]) != 0 && 
                           length(setdiff(pbids[!is.na(pbids)], "")) != 0) {
                           pbids <- setdiff(pbids, "")
                           pbids <- pbids[!is.na(pbids)]
                           paste(pbids, collapse = ";")
                       } else {
                           ""
                       }
                   }, "NA")
    }
}
```

```{r text-expdesign, results="asis", echo=FALSE}
cat(expDesignText(testType = stattest))
```

```{r get-fig-height, echo = FALSE}
if ("design" %in% names(testres$design)) {
    ## Overall fit
    ngroups <- length(unique(testres$design$sampleData$fc))
    fh <- max(4, 0.75 * ngroups)
} else {
    ## Separate fits - always two groups
    fh <- 4
}
```

```{r expdesign-plot, eval = (stattest == "limma"), echo = (stattest == "limma"), fig.width = 12, fig.height = fh, results = "asis"}
if ("design" %in% names(testres$design)) {
    cat("\n### Overall design \n")
    vd <- VisualizeDesign(
        testres$design$sampleData, designFormula = NULL, 
        designMatrix = testres$design$design)
    print(cowplot::plot_grid(
        plotlist = c(vd$plotlist, vd$cooccurrenceplots), nrow = 1)
    )
    cat("\n\n")
    cat("<details>\n<summary><b>\nClick to display design matrix and contrast(s)\n</b></summary>\n")
    cat("\n````\n")
    print(testres$design$design)
    cat("\n````\n")
    cat("\n````\n")
    cat("Contrast(s): \n")
    print(testres$design$contrasts)
    cat("\n````\n")
    cat("\n````\n")
    cat("Sample weights: \n")
    print(testres$design$sampleWeights)
    cat("\n````\n")
    cat("\n</details>\n\n")

} else {
    for (nm in names(testres$design)) {
        cat("\n###", nm, "\n")
        vd <- VisualizeDesign(
            testres$design[[nm]]$sampleData, designFormula = NULL, 
            designMatrix = testres$design[[nm]]$design)
        print(cowplot::plot_grid(
            plotlist = c(vd$plotlist, vd$cooccurrenceplots), nrow = 1)
        )
        cat("\n\n")
        cat("<details>\n<summary><b>\nClick to display design matrix and contrast(s)\n</b></summary>\n")
        cat("\n````\n")
        print(testres$design[[nm]]$design)
        cat("\n````\n")
        cat("\n````\n")
        cat("Contrast: \n")
        print(testres$design[[nm]]$contrast)
        cat("\n````\n")
        cat("\n````\n")
        cat("Sample weights: \n")
        print(testres$design[[nm]]$sampleWeights)
        cat("\n````\n")
        cat("\n</details>\n\n")
    }
}
```


```{r test-messages, echo = (length(testres$messages) > 0), eval = (length(testres$messages) > 0)}
testres$messages
```

```{r text-sa, results="asis", echo=FALSE, eval=(stattest == "limma")}
cat("\n## SA plots \n")
cat(saText(testType = stattest))
```
 
```{r plot-sa, fig.width = 12, fig.height = 4, warning = FALSE, eval = (stattest == "limma"), echo = (stattest == "limma")}
for (i in seq.int(ceiling(length(testres$tests) / 3))) {
    tmplist <- testres$tests[(seq_along(testres$tests) - 1) %/% 3 == (i - 1)]
    print(makeSAPlot(tmplist))
}
```

## Volcano plots

Below we display a volcano plot for each comparison. These plots are also 
saved to pdf files. In each plot, a subset of (up to `r volcanoMaxFeatures`) 
significant hits are indicated by name (selected as the ones with 
the largest Manhattan distance to the origin). These proteins are also used 
to generate STRING networks [@Szklarczyk2021string] (separately for the 
up- and downregulated ones), which are included in the pdf file. Any features 
explicitly requested (see the [table above](#settings-table)) are also labeled
in the volcano plots. 
In addition to these pdf files, if "complexes" is specified to be included in 
the feature collections (and tested for significance using camera), we also 
generate a multi-page pdf file showing the position of the features of each 
significantly differentially abundant complex in the volcano plot, as well 
as bar plots of the features' abundance values in the compared samples. This pdf 
file is only generated if there is at least one significant complex (with 
adjusted p-value below the specified complexFDRThr=`r complexFDRThr`). 


```{r volcano-plot, warning=FALSE, fig.width=10.5, fig.height=7.5, results="asis", eval = (stattest != "none"), echo = (stattest != "none")}
interactiveVolcanos <- htmltools::tagList()
for (nm in names(testres$tests)) {
    plots <- plotVolcano(
        sce = sce, res = testres$tests[[nm]], testType = stattest, 
        xv = NULL, yv = NULL, xvma = NULL, volcind = NULL, 
        plotnote = testres$plotnotes[[nm]], 
        plottitle = testres$plottitles[[nm]], 
        plotsubtitle = testres$plotsubtitles[[nm]],
        volcanoFeaturesToLabel = volcanoFeaturesToLabel, 
        volcanoMaxFeatures = volcanoMaxFeatures,
        volcanoLabelSign = volcanoLabelSign,
        baseFileName = paste0(sub("\\.Rmd$", "", knitr::current_input()),
                              "_volcano_", nm), 
        comparisonString = nm, 
        groupComposition = comparisonList$groupComposition[comparisonList$comparisons[[nm]]],
        stringDb = string_db,
        featureCollections = testres$featureCollections, 
        complexFDRThr = complexFDRThr,
        maxNbrComplexesToPlot = maxNbrComplexesToPlot,
        curveparam = testres$curveparams[[nm]],
        abundanceColPat = assaysForExport,
        xlab = "log2(fold change)", 
        ylab = "-log10(p-value)",
        xlabma = "Average abundance",
        labelOnlySignificant = TRUE,
        interactiveDisplayColumns = interactiveDisplayColumns, 
        interactiveGroupColumn = interactiveGroupColumn,
        maxTextWidthBarplot = 5.1)
    if (!is.null(plots$ggma) && !is.null(plots$ggwf) && !is.null(plots$ggbar)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        print(plots$ggma)
        for (ggb in plots$ggbar) print(ggb)
        print(plots$ggwf)
        cat("\n\n")
    } else if (!is.null(plots$ggma) && !is.null(plots$ggwf)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        print(plots$ggma)
        print(plots$ggwf)
        cat("\n\n")
    } else if (!is.null(plots$ggma) && !is.null(plots$ggbar)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        print(plots$ggma)
        for (ggb in plots$ggbar) print(ggb)
        cat("\n\n")
    } else if (!is.null(plots$ggbar) && !is.null(plots$ggwf)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        for (ggb in plots$ggbar) print(ggb)
        print(plots$ggwf)
        cat("\n\n")
    } else if (!is.null(plots$ggma)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        print(plots$ggma)
        cat("\n\n")
    } else if (!is.null(plots$ggbar)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        for (ggb in plots$ggbar) print(ggb)
        cat("\n\n")
    } else if (!is.null(plots$ggwf)) {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        print(plots$ggwf)
        cat("\n\n")
    } else {
        cat("\n\n### ", nm, " \n\n\n")
        print(plots$gg)
        cat("\n\n")
    }
    interactiveVolcanos[[nm]] <- plots$ggint
}
```

```{r interactive-volcanos-text, echo = FALSE, eval = addInteractiveVolcanos && stattest != "none", results = "asis"}
cat("## Interactive volcano plots")
```

```{r interactive-volcanos, echo = FALSE, eval = addInteractiveVolcanos && stattest != "none", fig.width = 10.5, fig.height = 8}
interactiveVolcanos
```

## Result export

For each comparison, we also save a text file with the "significant" features 
(defined as those colored in the volcano plots above). The features are 
ordered by the logFC value. In addition, we save a file with abundance values for 
all features that are "significant" in at least one comparison, across all the 
samples used in at least one comparison. 

```{r export-testres, eval = (stattest != "none"), echo = (stattest != "none")}
abundanceExport <- makeAbundanceExport(testresList = testres$tests, 
                                       abundancePrefix = assaysForExport)
write.table(abundanceExport, file = sub("\\.Rmd$", "_abundance_values_significant.txt",
                                   knitr::current_input()),
            row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")
```


```{r merge-tests, eval = (stattest != "none"), echo = (stattest != "none")}
## Merge results from all tests and add to rowData(sce)
tests <- testres$tests
for (nm in names(tests)) {
    idx <- which(colnames(tests[[nm]]) != "pid")
    colnames(tests[[nm]])[idx] <- paste0(nm, ".", colnames(tests[[nm]])[idx])
}
all_tests <- as.data.frame(Reduce(function(...) dplyr::full_join(..., by = "pid"),
                                  tests), optional = TRUE)
rownames(all_tests) <- all_tests$pid
all_tests$pid <- NULL

stopifnot(rownames(sce) == rownames(all_tests))
rowData(sce) <- cbind(rowData(sce), all_tests)
```

## Overlap among sets of significant features

The UpSet plot below shows the overlap among the "significant" features 
(defined as the ones that are colored in the volcano plots above, based 
on the user specifications) from the different comparisons. Note that if 
there are many comparisons, not all combinations may be displayed in 
the plot (only the 50 combinations with the largest number of features 
are shown, for interpretability reasons). Moreover, the UpSet plot will 
only be shown if at least two comparisons have been made, and there are 
at least two comparisons where any features were deemed significant.

```{r upset-tests, fig.width = 9, eval = (stattest != "none"), echo = (stattest != "none")}
tmpsign <- all_tests %>% dplyr::select(contains("showInVolcano")) + 0
tmpsign[is.na(tmpsign)] <- 0
## Only features that are significant in at least one comparison
tmpsign <- tmpsign[rowSums(tmpsign) > 0, , drop = FALSE]
colnames(tmpsign) <- gsub("\\.showInVolcano$", "", colnames(tmpsign))
if (length(tests) > 1 && sum(colSums(tmpsign) > 0) > 1) {
    ComplexUpset::upset(tmpsign, intersect = colnames(tmpsign), 
                        sort_intersections_by = "cardinality")
}
```

## Most significant feature sets

Finally, we display the top significant feature sets in each of the tested 
collections, for each comparison (if applicable). We recommend that the 
(adjusted) p-values for the feature sets is interpreted with caution, 
especially in situations where the feature abundances are measured on an 
isoform level and the feature sets are defined on the protein level, since 
there will be many (sometimes strongly correlated) features corresponding to 
a single gene or protein annotated to a feature set. 

```{r top-feature-sets, fig.width = 9, fig.height = 4 * length(testres$featureCollections) + 0.1, results="asis", eval = (stattest != "none"), echo = (stattest != "none")}
for (nm in names(testres$topsets)) {
    if (length(testres$topsets[[nm]]) > 0) {
        plts <- lapply(names(testres$topsets[[nm]]), function(snm) {
            df <- testres$topsets[[nm]][[snm]]
            if (nrow(df) > maxNbrComplexesToPlot) {
                df <- df[seq_len(maxNbrComplexesToPlot), ]
            }
            if (nrow(df) > 0) {
                ggplot(df %>% dplyr::mutate(set = factor(.data$set, levels = rev(.data$set))), 
                       aes(x = .data$set, y = -log10(.data[[paste0(nm, "_FDR")]]), 
                           fill = .data[[paste0(nm, "_Direction")]])) + 
                    geom_bar(stat = "identity") + 
                    coord_flip() + theme_bw() + 
                    labs(x = "", title = snm) + 
                    scale_fill_manual(values = c(Up = scales::muted("blue"), 
                                                 Down = scales::muted("red")), 
                                      name = "Direction") + 
                    theme(axis.text = element_text(size = 6))
            } else {
                NULL
            }
        })
        if (sum(sapply(plts, is.null)) < length(plts)) {
            cat("\n\n### ", nm, " \n\n\n")
            print(cowplot::plot_grid(plotlist = plts, ncol = 1, align = "v"))
            cat("\n\n") 
        }
    }
}
```


# Table with direct database links to sequences, functional information and predicted structures {#linktable}

The table below provides autogenerated links to the UniProt and 
AlphaFold pages (as well as selected organism-specific databases) for the 
majority protein IDs corresponding to each feature in the data set. 
The 'pid' column represents the unique feature ID used by `einprot`, and 
the `einprotLabel` column contains the user-defined feature labels.
UniProt is a resource of protein sequence and functional information 
hosted by EMBL-EBI, PIR and SIB. The AlphaFold Protein Structure Database, 
developed by DeepMind and EMBL-EBI, provides open access to protein structure 
predictions for the human proteome and other key proteins of interest. 
Note that (depending on the species) many proteins are not yet covered in 
AlphaFold (in this case, the link below will lead to a non-existent page), and 
that numeric values are rounded to four significant digits to increase 
readability. 

```{r linktable, warning = FALSE}
linkTable <- makeDbLinkTable(
    df = as.data.frame(rowData(sce)) %>%
        rownames_to_column("pid") %>%
        dplyr::select("pid", "einprotProtein", 
                      matches(setdiff(c("^einprotLabel$", linkTableColumns), ""), perl = TRUE)), 
    idCol = "einprotProtein", 
    speciesCommon = speciesInfo$speciesCommon, 
    addSpeciesSpecificColumns = TRUE, 
    convTablePomBase = pbconv, 
    convTableWormBase = wbconv,
    removeSuffix = TRUE, signifDigits = 4
) %>%
    dplyr::select(-.data$einprotProtein)
if (expType == "ProteomeDiscoverer") {
    linkTable <- linkTable %>%
        dplyr::relocate(any_of("Description"), .after = dplyr::last_col())
}
DT::datatable(
    as.data.frame(linkTable), escape = FALSE,
    filter = list(position = "top", clear = FALSE),
    extensions = "Buttons",
    options = list(scrollX = TRUE, pageLength = 20,
                   search = list(regex = FALSE, caseInsensitive = TRUE),
                   dom = "Bfrltip", buttons =
                       list(list(extend = "csv",
                                 filename = paste0(sub("\\.Rmd$", "", 
                                                       knitr::current_input()), "_linktable")),
                            list(extend = "excel", title = "",
                                 filename = paste0(sub("\\.Rmd$", "", 
                                                       knitr::current_input()), "_linktable"))))
)
```


# Assemble SingleCellExperiment object

We assemble all the information calculated above in a 
[SingleCellExperiment](https://bioconductor.org/packages/SingleCellExperiment/) 
object, which can later be used e.g. for exploration with 
[iSEE](https://bioconductor.org/packages/iSEE/) [@Rue-Albrecht2018isee].

```{r make-sce}
sce <- prepareFinalSCE(
    sce = sce, baseFileName = sub("\\.Rmd$", "", knitr::current_input()),
    featureCollections = testres$featureCollections, expType = expType)

## Add experiment metadata
addmeta <- list(
    aNames = aNames, 
    aName = aNames$assayInput,
    imputeMethod = imputeMethod,
    ctrlGroup = ctrlGroup,
    allPairwiseComparisons = allPairwiseComparisons,
    normMethod = normMethod,
    stattest = stattest,
    minlFC = minlFC,
    analysisDate = as.character(Sys.Date()),
    rmdFile = knitr::current_input(dir = TRUE),
    testres = testres,
    comparisonList = comparisonList
)
if (expType == "MaxQuant") {
    addmeta$mqFile <- mqFile
    addmeta$iColPattern <- iColPattern
} else if (expType == "DIANN") {
    addmeta$diannFile <- diannFile
} else if (expType == "FragPipe") {
    addmeta$fragpipeDir <- fragpipeDir
} else if (expType == "ProteomeDiscoverer") {
    addmeta$pdFile <- pdFile
    addmeta$modificationsCol <- modificationsCol
    addmeta$keepModifications <- keepModifications
} else if (expType == "Spectronaut") {
    addmeta$spectronautFile <- spectronautFile
}

S4Vectors::metadata(sce) <- c(
    S4Vectors::metadata(sce), 
    addmeta
)

sce
```


# Run PCA

```{r get-pca-features}
pcafeatures <- which(rowSums(!assay(sce, aNames$assayImputIndic)) >= minNbrValidValues)
```

We run a principal component analysis to obtain a reduced dimensionality 
representation of the data, in order to visualize the samples in two dimensions. 
The PCA is based on features with at least `r minNbrValidValues` 
non-imputed values (`r length(pcafeatures)` of the `r nrow(sce)` features).
The figure below shows the sample representation in the first two principal 
components, the fraction of variance explained by each of the principal 
components, and the features with the highest positive and negative 
loadings in the displayed components. 

```{r run-pca, warning=FALSE, fig.height=14, fig.width=8}
interactivePCAs <- htmltools::tagList()
for (a in unique(c(aNames$assayImputed, aNames$assayBatchCorr))) {
    pcares <- doPCA(sce = sce, assayName = a, ntop = Inf, 
                    ncomponents = min(10, ncol(sce) - 1),
                    plotpairs = list(c(1, 2)), maxTextWidthBarplot = 1.9, 
                    subset_row = pcafeatures)
    sce <- pcares$sce
    interactivePCAs[[a]] <- ggplotly(pcares$plotcoord[[1]], 
                                     width = 750, height = 500)
    for (plc in pcares$plotcombined) {
        print(plc)
    }
}
```

```{r interactive-pcas, echo = FALSE}
interactivePCAs
```

# Heatmap with hierarchical clustering

For another birds-eye view of the data, we represent it using a heatmap of 
the (imputed and normalized) log intensities, and cluster the samples and 
proteins using hierarchical clustering. In the first heatmap below, the values 
represent the normalized log intensities directly. In the second heatmap, 
the values for each protein have been centered to mean 0. The latter is also 
exported to a pdf file with row labels for further exploration. 

```{r heatmap, message=FALSE, fig.width = min(14, max(7, 0.5 * ncol(sce))), fig.height = 8/7 * min(14, max(7, 0.5 * ncol(sce)))}
if (addHeatmaps) {
    ht <- makeAbundanceHeatmap(sce, assayToPlot = aNames$assayImputed, doCenter = FALSE, 
                               settings = "report")
    draw(ht, merge_legends = TRUE)
    
    ## Centered
    ht <- makeAbundanceHeatmap(sce, assayToPlot = aNames$assayImputed, doCenter = TRUE,
                               settings = "report")
    draw(ht, merge_legends = TRUE)
}
```

```{r save-heatmap, results="hide"}
## Save to pdf (show row names, but no row dendrogram, order samples by group)
if (addHeatmaps) {
    pdf(sub("\\.Rmd$", "_heatmap_centered.pdf", knitr::current_input(dir = TRUE)),
        width = ncol(sce)/3.3 + 3.375, height = nrow(sce)/6.33 + 4)
    ht <- makeAbundanceHeatmap(sce, assayToPlot = aNames$assayImputed, doCenter = TRUE,
                               settings = "export")
    draw(ht, merge_legends = TRUE, heatmap_legend_side = "bottom", 
         annotation_legend_side = "bottom")
    dev.off()
}
```

We also perform a separate hierarchical clustering of the samples, based on 
Euclidean distance of feature-centered data, and Ward linkage.

```{r clustering, fig.height = 7, fig.width = min(14, max(7, 0.5 * ncol(sce)))}
plotassay <- assay(sce, aNames$assayImputed)
sampledists <- dist(scale(t(plotassay), center = TRUE, scale = FALSE))
plot(hclust(sampledists, method = "ward.D2"), hang = -1, xlab = "", sub = "")
```

# Correlation plot

The plot below shows the pairwise Pearson correlations between all pairs of 
samples, based on the `r aNames$assayImputed` assay. 

```{r corrplot, fig.height = 9, fig.width = 10}
plotassay <- assay(sce, aNames$assayImputed)
ggplot(data = as.data.frame(cor(plotassay, method = "pearson")) %>%
           rownames_to_column("sample1") %>% 
           tidyr::pivot_longer(names_to = "sample2", values_to = "correlation",
                               -"sample1"), 
       aes(x = .data$sample1, y = .data$sample2, fill = .data$correlation)) +
    geom_tile(color = "grey95", linewidth = 0.1) +
    scale_fill_gradient(low = "grey95", high = "darkblue") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    labs(x = "", y = "") + 
    scale_x_discrete(expand = c(0, 0)) + 
    scale_y_discrete(expand = c(0, 0))
```

# Save SingleCellExperiment object

The `SingleCellExperiment` object created above is saved in the following location: 

```{r save-sce}
sceFile <- sub("\\.Rmd$", paste0("_sce.rds"), knitr::current_input(dir = TRUE))
saveRDS(sce, file = sceFile)
sceFile
```

In addition, all feature information (the `rowData` of the `SingleCellExperiment`)
is written to a text file:

```{r save-rowdata}
textFile <- sub("\\.Rmd$", paste0("_feature_info.txt"), 
                knitr::current_input(dir = TRUE))
write.table(as.data.frame(rowData(sce)) %>% 
                rownames_to_column("FeatureID"), 
            file = textFile, row.names = FALSE, col.names = TRUE,
            quote = FALSE, sep = "\t")
textFile
```


# Explore the data interactively

For interactive exploration of your results, we generate a script to launch 
an adapted [iSEE](https://bioconductor.org/packages/iSEE/) interface. The 
script can be sourced from an R console: 

```{r isee-script-path, echo=FALSE}
iSEEScript <- sub("\\.Rmd$", paste0("_iSEE.R"), knitr::current_input(dir = TRUE))
```


```{r create-markdown-chunks-dynamically, include=FALSE}
out <- paste0("\n```{r source-isee, results='asis', echo=TRUE, eval=FALSE, class.source = 'fold-show'}\n\nsource('", 
              iSEEScript, "')\n\n```")
```

`r paste(knitr::knit(text = out), collapse = '\n')`


That will open up an iSEE session where you can interactively explore your data.

```{r make-isee-script, echo=FALSE}
## Feature to use for heatmap (make sure it has at least one detected value)
hmFeature <- rownames(sce)[
    min(which(rowSums(!is.na(assay(sce, aNames$assaysForExport[1]))) > 0))]
makeiSEEScript(iSEEScript = iSEEScript, sceFile = sceFile, 
               aName = aName, tests = tests, 
               assayForPlots = aNames$assayImputed,
               assayForHeatmaps = assaysForExport[1],
               featureForHeatmaps = hmFeature, 
               includeFeatureSetTable = (length(testres$featureCollections) > 0))
```

# Session info {#session-info}

This report was compiled with the following package versions:

<details>
<summary><b>
Click to expand
</b></summary>
```{r session-info, echo=FALSE}
sessionInfo()
```
</details>


# References


