{{YmlParametersStart}}

{{YmlParametersEnd}}

---
subtitle: "`r paste0('Generated with einprot v', packageVersion('einprot'))`"
date: "`r Sys.time()`"
output: 
    html_document:
        theme: united
        toc: true
        toc_float: true
        code_folding: hide
editor_options: 
  chunk_output_type: console
references:
- id: Ritchie2015limma
  title: limma powers differential expression analyses for RNA-sequencing and microarray studies
  author:
  - family: Ritchie
    given: M E
  - family: Phipson
    given: B
  - family: Wu
    given: D
  - family: Hu
    given: Y
  - family: Law
    given: C W
  - family: Shi
    given: W
  - family: Smyth
    given: G K
  container-title: Nucleic Acids Research
  volume: 43
  issue: 7
  page: e47
  type: article-journal
  URL: https://academic.oup.com/nar/article/43/7/e47/2414268
  issued:
    year: 2015
- id: McCarthy2009treat
  title: Testing significance relative to a fold-change threshold is a TREAT
  author:
  - family: McCarthy
    given: D J
  - family: Smyth
    given: G K
  container-title: Bioinformatics
  volume: 25
  page: 765-771
  type: article-journal
  URL: http://bioinformatics.oxfordjournals.org/content/25/6/765
  issued:
    year: 2009
- id: Wu2012camera
  title: Camera:a competitive gene set test accounting for inter-gene correlation
  author:
  - family: Wu
    given: D
  - family: Smyth
    given: G K
  container-title: Nucleic Acids Research
  volume: 40
  issue: 17
  page: e133
  type: article-journal
  URL: https://academic.oup.com/nar/article/40/17/e133/2411151
  issued:
    year: 2012
- id: Phipson2016robust
  title: Robust hyperparameter estimation protects against hypervariable genes and improves power to detect differential expression
  author:
  - family: Phipson
    given: B
  - family: Lee
    given: S
  - family: Majewski
    given: I J
  - family: Alexander
    given: W S
  - family: Smyth
    given: G K
  container-title: Annals of Applied Statistics 
  volume: 10
  page: 946-963
  type: article-journal
  URL: http://projecteuclid.org/euclid.aoas/1469199900
  issued:
    year: 2016
- id: Tusher2001sam
  title: Significance analysis of microarrays applied to the ionizing radiation response
  author:
  - family: Tusher
    given: V G
  - family: Tibshirani
    given: R
  - family: Chu
    given: G
  container-title: Proceedings of the National Academy of Sciences of the United States of America 
  volume: 98
  page: 5116-5121
  type: article-journal
  URL: https://www.pnas.org/content/98/9/5116
  issued:
    year: 2001
- id: Tyanova2016perseus
  title: The Perseus computational platform for comprehensive analysis of (prote)omics data
  author:
  - family: Tyanova
    given: S
  - family: Temu
    given: T
  - family: Sinitcyn
    given: P
  - family: Carlson
    given: A
  - family: Hein
    given: M Y
  - family: Geiger
    given: T
  - family: Mann
    given: M
  - family: Cox
    given: J
  container-title: Nature Methods 
  volume: 13
  page: 731-740
  type: article-journal
  URL: https://www.nature.com/articles/nmeth.3901
  issued:
    year: 2016
- id: Orsburn2021PD
  title: Proteome discoverer-a community enhanced data processing suite for protein informatics 
  author:
  - family: Orsburn
    given: BC
  container-title: J Proteome Res.
  volume: 20(7)
  page: 3497â€“3507
  type: article-journal
  URL: https://www.mdpi.com/2227-7382/9/1/15
  issued:
    year: 2021
---

{{ConfigParametersStart}}

{{ConfigParametersEnd}}

---
title: "`r reportTitle`"
author: "`r reportAuthor`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi = 200)
```

```{r load-pkg, echo=FALSE}
## Load packages
suppressPackageStartupMessages({
    library(QFeatures)
    library(SummarizedExperiment)
    library(SingleCellExperiment)
    library(imputeLCMD)
    library(rrcovNA)
    library(scater)
    library(dplyr)
    library(tibble)
    library(tidyr)
    library(ggplot2)
    library(ggrepel)
    library(cowplot)
    library(plotly)
    library(UpSetR)
    library(circlize)
    library(ComplexHeatmap)
    library(DT)
    library(STRINGdb)
    library(einprot, lib.loc = "/tungstenfs/groups/gbioinfo/sonechar/FMIgroups/Proteomics/devel_lib_einprot/")
})
```

This report describes a reproducible end-to-end analysis of a proteomics dataset quantified 
with [Proteome Discoverer](https://www.thermofisher.com/ch/en/home/industrial/mass-spectrometry/liquid-chromatography-mass-spectrometry-lc-ms/lc-ms-software/multi-omics-data-analysis/proteome-discoverer-software.html) [@Orsburn2021PD]. 
Most of the code is hidden by default, 
but can be displayed by clicking on the `Code` buttons (or by selecting 
`Code -> Show All Code` in the top right corner of the report).

```{r get-basic-info, echo=FALSE}
## Get species info and define STRINGdb object
speciesInfo <- getSpeciesInfo(species)

## If needed and not provided, define path to complex DB 
## (will be added to summary table below)
if ("complexes" %in% includeFeatureCollections && is.null(complexDbPath)) {
    complexDbPath <- system.file(EINPROT_COMPLEXES_FILE,
                                 package = "einprot", 
                                 lib.loc = "/tungstenfs/groups/gbioinfo/sonechar/FMIgroups/Proteomics/devel_lib_einprot/")
}
```

# Experiment details

```{r exp-table, echo=FALSE}
makeTableFromList(c(experimentInfo, 
                    list(
                        "Species" = speciesInfo$species,
                        "Species (common)" = speciesInfo$speciesCommon,
                        "Taxonomic ID" = speciesInfo$taxId
                    )))
```

## ProteomeDiscoverer analysis summary

```{r pd-table, echo=FALSE}
pd <- readProteomeDiscovererInfo(pdOutputFolder, pdResultName, 
                                 pdAnalysisFile)
pdFile <- file.path(pdOutputFolder, paste0(pdResultName, "_Proteins.txt"))
pd <- c(list("PD proteins file" = pdFile), pd)
makeTableFromList(pd)
```

# Settings {#settings-table}

The following settings define the analysis that will be performed below.

```{r settings-table, echo = FALSE}
settingsList <- list(
    "Name of base assay" = aName,
    "Column pattern" = iColPattern,
    "Include only samples (if applicable)" = paste(includeOnlySamples, 
                                                   collapse = ", "),
    "Exclude samples" = paste(excludeSamples, collapse = ", "),
    "Min. number of peptides" = minPeptides,
    "Min. protein score" = minScore,
    "Imputation method" = imputeMethod,
    "Min. nbr valid values" = minNbrValidValues,
    "Groups to merge" = paste(unlist(
        lapply(names(mergeGroups), 
               function(nm) paste0(nm, ":", paste(mergeGroups[[nm]], collapse = ",")))),
        collapse = "; "),
    "Comparisons" = paste(unlist(lapply(comparisons, 
                                        function(x) paste(x, collapse = " vs "))),
                          collapse = "; "),
    "Control group" = ctrlGroup,
    "Do all pairwise comparisons" = allPairwiseComparisons,
    "Normalization method" = normMethod,
    "Statistical test" = stattest,
    "Minimal fold change (limma/treat)" = minlFC,
    "Adjusted p-value threshold for volcano plots" = volcanoAdjPvalThr,
    "Log2 FC threshold for volcano plots" = volcanoLog2FCThr,
    "Max nbr features to indicate in volcano plots" = volcanoMaxFeatures,
    "s0" = volcanoS0,
    "Features to always label in volcano plots" = paste(volcanoFeaturesToLabel,
                                                        collapse = ", "),
    "Feature collections" = paste(includeFeatureCollections, collapse = "; "),
    "Complexes file" = gsub(".+\\/(.+.rds)", "\\1", complexDbPath),
    "Complexes from species" = complexSpecies,
    "Custom complexes" = names(customComplexes),
    "FDR Threshold for complexes" = complexFDRThr,
    "Number of permutations" = nperm,
    "Random seed" = seed)

if (stattest == "ttest") {
    settingsList <- settingsList[!(names(settingsList) %in% 
                                       c("Minimal fold change (limma/treat)",
                                         "Log2 FC threshold for volcano plots"))]
}
if (stattest == "limma") {
    settingsList <- settingsList[!(names(settingsList) %in% 
                                       c("s0", "Number of permutations"))]
}

makeTableFromList(settingsList)
```

# Read PD output

The input to this workflow is a `Proteins.txt` file from Proteome Discoverer 
(see path in the table above). We read the PD intensities into `R` 
and store them in a 
[QFeatures](https://bioconductor.org/packages/QFeatures/) object. This object 
will later be expanded with additional data, such as transformed and 
imputed quantifications. 

Based on the 'Column pattern' indicated in the table above, the following columns 
are determined to contain the intensity values of interest:

```{r get-icols-all}
ics <- getIntensityColumns(inFile = pdFile, iColPattern = iColPattern,
                           includeOnlySamples = includeOnlySamples,
                           excludeSamples = excludeSamples,
                           stopIfEmpty = TRUE)
ics$iColsAll
```

After any explicit selection of samples to include or exclude, as specified 
above, the following samples are retained and will be available for use in the 
downstream analysis: 

```{r get-icols}
ics$iCols
```

At this point, the QFeatures object holds an _assay_ with the intensities from 
PD, as well as annotations corresponding to all other columns in the 
PD file. The assay name will be `r aName`, as specified via the 
`aName` variable above. 

```{r read-data}
## Read Proteome Discoverer output
qft <- QFeatures::readQFeatures(pdFile, ecol = ics$iCols, name = aName, sep = "\t")

## Make sure that the columns used for filtering later are character vectors
rowData(qft[[1]])$Contaminant <- as.character(rowData(qft[[1]])$Contaminant)

qft
```


# Modify feature names

The feature ID used when reading the data above are the numeric indices 
provided in the 'id' column. We replace these IDs with more interpretable 
ones, corresponding to the gene symbol, or, in cases where that is missing, 
with the accession. 

```{r fix-ids}
qft <- fixFeatureIds(qft, geneIdCol = "Gene.Symbol",
                     proteinIdCol = "Accession")
```


# Add sample annotations

Next, we compile the sample annotations. The sample ID will be extracted 
from the column names in the `ProteomeDiscoverer` file, by removing the provided 
`iColPattern` from the extracted intensity columns. The `group` 
column will be used to define groups for the statistical testing later. 
Please check that the table below correspond to your expectations.

```{r add-sampleinfo}
qft <- addSampleAnnots(qft = qft, iColPattern = iColPattern, 
                       sampleAnnot = sampleAnnot, mergeGroups = mergeGroups)

DT::datatable(as.data.frame(colData(qft)),
              options = list(scrollX = TRUE, pageLength = 20))
```

# Overall distribution of protein intensities

The box plot below displays the distribution of raw protein intensities 
in each sample, on a log scale (excluding any missing values).

```{r intensity-distribution, warning=FALSE, message=FALSE}
makeIntensityBoxplots(qft = qft, assayName = aName, doLog = TRUE, 
                      ylab = "Raw intensity")
```

# Filter out contaminants and proteins with low confidence

Next, we filter out any features classified by PD as potential contaminants, 
and features we may remove protein identifications based on score and number 
of peptides (i.e. to exclude one-hit wonders). 

```{r filter-features}
nbrFeaturesBefore <- nrow(qft[[aName]])
filtdf <- as.data.frame(rowData(qft[[aName]])) %>%
    dplyr::select(Contaminant, Number.of.Peptides, Score.Sequest.HT.Sequest.HT) %>%
    dplyr::mutate(across(c(Contaminant), 
                         function(x) as.numeric(x == "True"))) %>%
    dplyr::mutate(Number.of.Peptides = as.numeric(Number.of.Peptides < minPeptides), 
                  Score.Sequest.HT.Sequest.HT = as.numeric(Score.Sequest.HT.Sequest.HT < minScore)) 
qft <- qft %>%
    filterFeatures(~ Contaminant == "False") %>%
    filterFeatures(~ Number.of.Peptides >= minPeptides) %>%
    filterFeatures(~ Score.Sequest.HT.Sequest.HT >= minScore)
nbrFeaturesAfter <- nrow(qft[[aName]])

UpSetR::upset(filtdf)
```

This filtering removed `r nbrFeaturesBefore - nbrFeaturesAfter` features. 
The new `qft` object has `r nbrFeaturesAfter` features.

# Prepare feature collections for later testing

In addition to testing individual proteins for differential abundance 
between groups, we can also test collections of proteins. Here we 
define the collections that will be used. 

```{r prepare-feature-collections}
(featureCollections <- prepareFeatureCollections(
    qft = qft, idCol = "Gene.Symbol", 
    includeFeatureCollections = includeFeatureCollections,
    complexDbPath = complexDbPath, speciesInfo = speciesInfo,
    complexSpecies = complexSpecies, customComplexes = customComplexes,
    minSizeToKeep = 2))
```

# Apply a log2 transformation

Before the downstream analysis, we log2-transform the measured intensities. We also 
add an additional assay to keep track of the position of the missing values
(which will be imputed later). The `qft` object now has three assays:

```{r log-transform}
qft <- logTransform(qft, base = 2, i = aName,
                    name = paste0("log2_", aName))
qft <- logTransform(qft, base = 2, i = aName,
                    name = paste0("log2_", aName, "_withNA"))

## Add assay indicating missing values, which will be imputed
tmp <- qft[[paste0("log2_", aName)]]
assay(tmp) <- !is.finite(assay(tmp))
qft <- addAssay(qft, tmp, name = paste0("imputed_", aName))
qft

## Set the assay to use for tests later (depending on the downstream steps,
## this may be updated below)
assayForTests <- paste0("log2_", aName)
```

# Visualize missing value patterns

The plot below shows the fraction of the total set of features that are detected 
(with a non-missing value) in each of the samples.

```{r visualize-missing}
## Replace zeros/-Inf values by explicit NA values in the assays
qft <- zeroIsNA(qft, aName)
qft <- infIsNA(qft, paste0("log2_", aName))
qft <- infIsNA(qft, paste0("log2_", aName, "_withNA"))

## Count number of NA values
nbr_na <- nNA(qft, i = seq_along(qft))

plotFractionDetectedPerSample(dfNA = nbr_na$nNAcols, aName = aName)
```

We also plot the number of features that are detected in a given number 
of samples.

```{r visualize-missing-2}
plotDetectedInSamples(dfNA = nbr_na$nNArows, aName = aName)
```

# Imputation

Next, we apply the `r imputeMethod` method to perform imputation 
of the log2-transformed data.

```{r impute-minprob, eval=(imputeMethod=="MinProb"), echo=(imputeMethod=="MinProb"), results="hide"}
set.seed(seed)
qft <- impute(qft, method = "MinProb", i = paste0("log2_", aName))
```

```{r impute-impseqrob, eval=(imputeMethod=="impSeqRob"), echo=(imputeMethod=="impSeqRob")}
set.seed(seed)
tmp <- impSeqRob(assay(qft[[paste0("log2_", aName)]]))
assay(qft[[paste0("log2_", aName)]]) <- tmp$x
```

The following histograms show the distribution of imputed and non-imputed 
values in each sample. 

```{r plot-imputation, fig.width=7, fig.height=7, message = FALSE}
plotImputationDistribution(qft, assayToPlot = paste0("log2_", aName), 
                           assayImputation = paste0("imputed_", aName),
                           iColPattern = iColPattern, 
                           xlab = "log2 intensity")
```

# Overall distribution of log2 protein intensities

Next we consider the overall distribution of log2-intensities among the 
samples (after imputation).

```{r intensity-distribution-imputed}
makeIntensityBoxplots(qft = qft, assayName = paste0("log2_", aName),
                      doLog = FALSE, 
                      ylab = "log2 intensity (after imputation")
```

We also plot the mean-variance relationship of log2-intensities (after imputation).

```{r mean-var-imputed, message=FALSE}
makeMeanSDPlot(qft = qft, assayName = paste0("log2_", aName),
               xlab = "Mean log2 intensity (after imputation)",
               ylab = "SD of log2 intensity (after imputation)")
```


```{r no-norm, results="asis", echo=FALSE, eval=(normMethod == "none")}
cat(paste0("The log2 intensities are not normalized further across samples ", 
           "since 'normMethod' is set to 'none'."))
```

```{r do-norm, results="asis", echo=FALSE, eval=(normMethod != "none")}
cat(paste0("The log2 intensities are next normalized across samples ", 
           "using the ", normMethod, " method."))
```

```{r normalize, echo=(normMethod != "none"), eval=(normMethod != "none"), message=FALSE}
qft <- normalize(qft, i = paste0("log2_", aName),
                 name = paste0("log2norm_", aName),
                 method = normMethod)

## If data is normalized, use normalized values for testing
assayForTests <- paste0("log2norm_", aName)

makeIntensityBoxplots(qft = qft, assayName = paste0("log2norm_", aName),
                      doLog = FALSE, 
                      ylab = "log2 intensity (after imputation and normalization)")

makeMeanSDPlot(qft = qft, assayName = paste0("log2norm_", aName), 
               xlab = "Mean log2 intensity (after imputation and normalization)", 
               ylab = "SD of log2 intensity (after imputation and normalization)")
```

# Statistical testing

For each feature, we then compare the (possibly imputed) log2 intensities 
between groups. 

```{r text-limma, results="asis", echo=FALSE, eval=(stattest == "limma")}
cat(limmaText())
```

```{r text-ttest, results="asis", echo=FALSE, eval=(stattest == "ttest")}
cat(ttestText())
```

The `r assayForTests` assay will be used for the tests. The 
following pairwise comparisons will be performed (in each case, the 
first listed group will be the 'baseline' group): 

```{r initialize-tests}
## Initialize list for test results and plot titles/notes
tests <- list()
plottitles <- list()
plotnotes <- list()
plotsubtitles <- list()
curveparams <- list()

(comparisons <- makeListOfComparisons(
    allGroups = unique(qft$group), comparisons = comparisons, 
    allPairwiseComparisons = allPairwiseComparisons,
    ctrlGroup = ctrlGroup))
```

```{r run-test}
for (cmp in comparisons) {
    outres <- runTest(qft = qft, comparison = cmp, testType = stattest, 
                      assayForTests = assayForTests,
                      assayImputation = paste0("imputed_", aName), 
                      minNbrValidValues = minNbrValidValues,
                      minlFC = minlFC, featureCollections = featureCollections, 
                      complexFDRThr = complexFDRThr,
                      volcanoAdjPvalThr = volcanoAdjPvalThr, 
                      volcanoLog2FCThr = volcanoLog2FCThr,
                      baseFileName = sub("\\.Rmd$", "", knitr::current_input()),
                      iColPattern = iColPattern, seed = seed, nperm = nperm,
                      volcanoS0 = volcanoS0, aName = aName, addiBAQvalues = FALSE)
    plottitles[[paste0(cmp[2], "_vs_", cmp[1])]] <- outres$plottitle
    plotsubtitles[[paste0(cmp[2], "_vs_", cmp[1])]] <- outres$plotsubtitle
    plotnotes[[paste0(cmp[2], "_vs_", cmp[1])]] <- outres$plotnote
    tests[[paste0(cmp[2], "_vs_", cmp[1])]] <- outres$res
    featureCollections <- outres$featureCollections
    curveparams[[paste0(cmp[2], "_vs_", cmp[1])]] <- outres$curveparam
}
```


Below we display a volcano plot for each comparison. These plots are also 
saved to pdf files. In each plot, a subset of the significant hits are 
indicated by name (n=`r volcanoMaxFeatures`, selected as the ones with 
the largest Manhattan distance to the origin). Any features 
explicitly requested (see the [table above](#settings-table)) are also labeled
in the volcano plots. 
In addition to these pdf files, if "complexes" is specified to be included in 
the feature collections (and tested for significance using camera), we also 
generate a multi-page pdf file showing the position of the proteins of each 
significantly differentially abundant complex in the volcano plot, as well 
as bar plots of the proteins' abundance values in the compared samples. This pdf 
file is only generated if there is at least one significant complex (with 
adjusted p-value below the specified complexFDRThr=`r complexFDRThr`). 

```{r volcano-limma, echo=(stattest=="limma"), eval=(stattest=="limma"), warning=FALSE, fig.width=10.5, fig.height=7.5}
## Make a volcano plot for each comparison and save to a pdf file
xv <- "logFC"
yv <- "mlog10p"
apv <- "adj.P.Val"
volcind <- "showInVolcano"
interactiveVolcanos <- htmltools::tagList()
```

```{r volcano-ttest, echo=(stattest=="ttest"), eval=(stattest=="ttest"), warning=FALSE, fig.width=10.5, fig.height=7.5}
## Make a volcano plot for each comparison and save to a pdf file
xv <- "logFC"
yv <- "mlog10p"
apv <- "adj.P.Val"
tv <- "sam"
volcind <- "showInVolcano"
interactiveVolcanos <- htmltools::tagList()
```

```{r volcano-plot, warning=FALSE, fig.width=10.5, fig.height=7.5}
for (nm in names(tests)) {
    plots <- plotVolcano(
        qft = qft, res = tests[[nm]], testType = stattest, 
        xv = xv, yv = yv, volcind = volcind, 
        plotnote = plotnotes[[nm]], 
        plottitle = plottitles[[nm]], 
        plotsubtitle = plotsubtitles[[nm]],
        volcanoFeaturesToLabel = volcanoFeaturesToLabel, 
        volcanoMaxFeatures = volcanoMaxFeatures,
        baseFileName = sub("\\.Rmd$", "", knitr::current_input()), 
        comparisonString = nm, stringDb = NULL,
        featureCollections = featureCollections, 
        complexFDRThr = complexFDRThr,
        curveparam = curveparams[[nm]])
    print(plots$gg)
    interactiveVolcanos[[nm]] <- plots$ggint
}
```

```{r interactive-volcanos, echo = FALSE, eval = addInteractiveVolcanos, fig.width = 10.5, fig.height = 8}
interactiveVolcanos
```

For each comparison, we also save a text file with the "significant" features 
(defined as those colored in the volcano plots above). The features are 
ordered by the logFC value. 

```{r merge-test-res}
## Merge results from all tests
for (nm in names(tests)) {
    idx <- which(colnames(tests[[nm]]) != "pid")
    colnames(tests[[nm]])[idx] <- paste0(nm, ".", colnames(tests[[nm]])[idx])
}
all_tests <- as.data.frame(Reduce(function(...) dplyr::full_join(..., by = "pid"),
                                  tests), optional = TRUE)
rownames(all_tests) <- all_tests$pid
all_tests$pid <- NULL
```

The UpSet plot below shows the overlap among the "significant" proteins 
(defined as the ones that are colored in the volcano plots above, based 
on the user specifications) from the different comparisons. Note that if 
there are many comparisons, not all combinations may be displayed in 
the plot (only the 50 combinations with the largest number of proteins 
are shown, for interpretability reasons). Moreover, the UpSet plot will 
only be shown if at least two comparisons have been made, and there are 
at least two comparisons where any proteins were deemed significant.

```{r upset-test, fig.width = 9}
tmpsign <- all_tests %>% dplyr::select(contains("showInVolcano")) + 0
tmpsign[is.na(tmpsign)] <- 0
colnames(tmpsign) <- gsub("\\.showInVolcano$", "", colnames(tmpsign))
if (length(tests) > 1 && sum(colSums(tmpsign) > 0) > 1) {
    UpSetR::upset(tmpsign, nsets = length(tests), nintersects = 50, 
                  order.by = "freq")
}
```

# Table with direct database links to sequences, functional information and predicted structures

The table below provides autogenerated links to the UniProt and 
AlphaFold pages (as well as selected organism-specific databases) for the 
majority protein IDs corresponding to each feature in the data set. 
UniProt is a resource of protein sequence and functional information 
hosted by EMBL-EBI, PIR and SIB. The AlphaFold Protein Structure Database, 
developed by DeepMind and EMBL-EBI, provides open access to protein structure 
predictions for the human proteome and other key proteins of interest. 
Note that (depending on the species) many proteins are not yet covered in 
AlphaFold (in this case, the link below will lead to a non-existent page). 

```{r linktable}
pbconv <- readRDS(system.file(EINPROT_POMBASE_CONVTABLE,
                              package = "einprot", 
                              lib.loc = "/tungstenfs/groups/gbioinfo/sonechar/FMIgroups/Proteomics/devel_lib_einprot/"))
wbconv <- readRDS(system.file(EINPROT_WORMBASE_CONVTABLE,
                              package = "einprot", 
                              lib.loc = "/tungstenfs/groups/gbioinfo/sonechar/FMIgroups/Proteomics/devel_lib_einprot/"))

linkTable <- makeDbLinkTable(
    df = as.data.frame(rowData(qft[[1]])) %>%
        tibble::rownames_to_column("pid") %>%
        dplyr::select(pid, Majority.protein.IDs), 
    idCol = "Majority.protein.IDs", 
    speciesCommon = speciesInfo$speciesCommon, 
    addSpeciesSpecificColumns = TRUE, 
    convTablePomBase = pbconv, 
    convTableWormBase = wbconv
) %>%
    dplyr::select(-Majority.protein.IDs)
DT::datatable(as.data.frame(linkTable), escape = FALSE,
              options = list(scrollX = TRUE, pageLength = 20))
```


# Assemble SingleCellExperiment object

Finally, we assemble all the information calculated above in a 
[SingleCellExperiment](https://bioconductor.org/packages/SingleCellExperiment/) 
object, which can later be used e.g. for exploration with 
[iSEE](https://bioconductor.org/packages/iSEE/).

```{r make-sce}
sce <- assembleSCE(qft = qft, aName = aName, testResults = all_tests, 
                   iColPattern = iColPattern, iColsAll = ics$iColsAll, 
                   baseFileName = sub("\\.Rmd$", "", knitr::current_input()), 
                   nbrNA = nbr_na, featureCollections = featureCollections,
                   expType = "ProteomeDiscoverer")


## Add experiment metadata
S4Vectors::metadata(sce) <- c(
    S4Vectors::metadata(sce), 
    list(
        pdFile = pdFile,
        aName = aName,
        iColPattern = iColPattern,
        imputeMethod = imputeMethod,
        ctrlGroup = ctrlGroup,
        allPairwiseComparisons = allPairwiseComparisons,
        normMethod = normMethod,
        stattest = stattest,
        minlFC = minlFC,
        analysisDate = as.character(Sys.Date()),
        rmdFile = knitr::current_input(dir = TRUE)
    )
)

sce
```


# Run PCA

We run a principal component analysis to obtain a reduced dimensionality 
representation of the data, in order to visualize the samples in two dimensions. 

```{r run-pca}
sce <- scater::runPCA(sce, exprs_values = assayForTests, name = "PCA", 
                      ncomponents = 10, ntop = Inf,
                      BSPARAM = BiocSingular::ExactParam())
pcadf <- data.frame(sampleLabel = colnames(sce), 
                    reducedDim(sce, "PCA")[, 1:2], 
                    group = sce$group)
plotly::ggplotly(
    ggplot(pcadf, aes(x = PC1, y = PC2, color = group, text = sampleLabel)) + 
        geom_point(alpha = 0.5, size = 5) + 
        theme_cowplot()
)
```

# Hierarchical clustering

For another birds-eye view of the data, we represent it using a hierarchical 
clustering of the samples, based on Euclidean distance of feature-centered 
data, and Ward linkage.

```{r clustering, fig.height = 7}
plotassay <- assay(sce, assayForTests)
colnames(plotassay) <- sub(iColPattern, "", colnames(plotassay))
sampledists <- dist(scale(t(plotassay), center = TRUE, scale = FALSE))
plot(hclust(sampledists, method = "ward.D2"), hang = -1, xlab = "")
```


# Save SingleCellExperiment object

The `SingleCellExperiment` object created above is saved in the following location: 

```{r save-sce}
sceFile <- sub("\\.Rmd$", paste0("_sce.rds"), knitr::current_input(dir = TRUE))
saveRDS(sce, file = sceFile)
sceFile
```

In addition, all feature information (the `rowData` of the `SingleCellExperiment`)
is written to a text file:

```{r save-rowdata}
textFile <- sub("\\.Rmd$", paste0("_feature_info.txt"), 
                knitr::current_input(dir = TRUE))
write.table(as.data.frame(rowData(sce)) %>% 
                tibble::rownames_to_column("FeatureID"), 
            file = textFile, row.names = FALSE, col.names = TRUE,
            quote = FALSE, sep = "\t")
textFile
```


# Explore the data interactively

For interactive exploration of your results, we generate a script to launch 
an adapted [iSEE](https://bioconductor.org/packages/iSEE/) interface. The 
script can be sourced from an R console: 

```{r isee-script-path, echo=FALSE}
iSEEScript <- sub("\\.Rmd$", paste0("_iSEE.R"), knitr::current_input(dir = TRUE))
```


```{r create-markdown-chunks-dynamically, include=FALSE}
out <- paste0("\n```{r, results='asis', echo=TRUE, eval=FALSE, class.source = 'fold-show'}\n\nsource('", 
              iSEEScript, "')\n\n```")
```

`r paste(knitr::knit(text = out), collapse = '\n')`


That will open up an iSEE session where you can interactively explore your data.

```{r make-isee-script, echo=FALSE}
makeiSEEScript(iSEEScript = iSEEScript, sceFile = sceFile, 
               aName = aName, tests = tests, 
               assayForPlots = assayForTests,
               assayForHeatmaps = "Abundance")
```

# Session info {#session-info}

This report was compiled with the following package versions:

<details>
<summary><b>
Click to expand
</b></summary>
```{r session-info, echo=FALSE}
sessionInfo()
```
</details>

# References


